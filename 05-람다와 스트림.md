### 익명 클래스보다는 람다를 사용하자

---

이전에는 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스를 사용 ( 혹은 추상 클래스 )

⇒ 이런 인터페이스의 인스턴스를 함수 객체라고 하며, 특정 함수나 동작을 나타내는데 사용<br><br>

이러한 함수 객체를 만드는 주요 수단은 익명 클래스를 통해서 이루어졌음

```kotlin
// ex. 문자열을 길이순으로 정렬하는데, 정렬을 위한 비교 함수로 익명 클래스를 사용

Collections.sort(words, new Comparator<String>() {
	public int compare(String s1, String s2) {
		return Integer.compare(s1.length(), s2.length());
	}
))

익명 클래스를 전달하는 대신 클래스를 생성하여 인스턴스를 전달해도 되지만, 한 번 쓰고 말 클래스를 만들
필요는 없기에 굳이 정의하지 않는 것
```
<br>

하지만, 이러한 익명 클래스 방식은 코드가 너무 길기 때문에 자바에서 적합하지 않았음

자바 8 이후에서는 추상 메서드를 하나만 가지는 인터페이스의 인스턴스를 람다식을 사용해 만들 수 있게 됨

( 함수형 인터페이스, 즉 추상 메서드를 딱 하나만 가지고 있는 인터페이스에만 람다식으로 인스턴스를 생성 가능 )

```kotlin
// 익명 클래스 대신 람다식을 사용한 코드
Collections.sort(words, 
	(s1, s2) -> Integer.compare(s1.length(), s2.length())
)
```

여기서 람다, 매개변수 (s1, s2), 반환값의 타입은 각각 `Comparator<String>,` `String,` `int`이지만 언급하지 않지만, 이는 컴파일러가 문맥에 따라 타입을 추론해주기 때문

컴파일러가 타입을 추론해내지 못한다면 직접 명시해줘야함

`타입을 명시해야 코드가 더 명확해질 때만을 제외하고는, 람다의 모든 매개변수 타입을 생략하자` <br><br>

람다 자리에 비교자 생성 메서드를 사용하면 더 간결하게 만들 수 있음

```kotlin
Collections.sort(words, comparingInt(String::length));
```
<br>

자바 8에서 List 인터페이스에 추가된 sort 메서드를 사용하면 더욱 짧아짐

```kotlin
words.sort(comparingInt(String::length));
```
<br>

**람다를 언어 차원에서 지원하면서 기존에는 적합하지 않았던 곳에서도 함수 객체를 사용 가능**

```kotlin
// 각 상수에서 apply 메서드를 재정의해야함 
public enum Operation {
	PLUS("+") {
		public double apply(double x, double y){ return x + y; }
	}
	
	MINUS("-") {
		public double apply(double x, double y){ return x - y; }
	}
	
	TIMES("*") {
		public double apply(double x, double y){ return x * y; }
	}
	
	DIVIDE("/") {
		public double apply(double x, double y){ return x / y; }
	}
	
	private final String symbol;
	
	Operation(String symbol) {this.symbol = symbol;}
	
	@Override public String toString(){return symbol;}
	
	public abstract double apply(double x, double y);
}

-- 아래와 같이 사용

public class EnumSingleTest {
    public static void main(String[] args) {
        double result = Operation.PLUS.apply(5, 2);
        log.info(result); // 7.0
    }
}
```
<br>

```kotlin
// 람다를 이용한 방식
public enum Operation {
	PLUS("+", (x, y) -> x + y)
	MINUS("-", (x, y) -> x - y)
	TIMES("*", (x, y) -> x * y)
	DIVIDE("/", (x, y) -> x / y)
	
	private final String symbol;
	private final DoubleBinaryOperator op;
	
	Operation(String symbol, DoubleBinaryOperator op) {
		this.symbol = symbol;
		this.op = op
	}
	
	@Override public String toString(){ return symbol; }
	
	public double apply(double x, double y) {
		return op.applyAsDouble(x, y);
	}
}
```
<br>

람다 기반 코드를 보면 상수별 클래스 몸체를 사용하는 방식은 필요가 없다고 생각할 수도 있지만, 꼭 그렇진 않음

메서드와 클래스와 달리 람다는 이름도 없고 문서화도 하지 못하므로, 코드 자체로 동작히 명확히 설명되지 않거나, 코드의 수가 길다면 람다를 사용해서는 안됨

( 람다식이 3, 4줄 이상 넘어간다면 간단히 줄여보거나 람다를 사용하지 않는 방법으로 리팩터링 생각해보기 )<br><br>

**람다로 대체할 수 없는 부분**

- 람다는 함수형 인터페이스에서만 쓰임
    
    ⇒ 추상 클래스의 인스턴스를 만들 때 람다를 사용하지 못함 ( 익명 클래스 사용해야 함 )
    
    ⇒ 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 사용하지 못함 ( .. )<br><br>
    

- 람다는 자기 자신을 참조할 수 없음
    
    람다에서의 this 키워드는 바깥 인스턴스를 가르키므로, 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 사용해야 함
    
    ```kotlin
    class Outer {
        void run() {
            Runnable r = () -> {
                System.out.println(this); // Outer의 인스턴스를 가르킴
            };
            r.run();
        }
    }
    
    익명 클래스로 Runnable을 만들면 this는 그 익명 클래스의 인스턴스 
    → 즉, Runnable 구현 객체 자신을 가리킴
    
    람다식으로 Runnable을 만들면 this는 람다를 감싸고 있는 Outer 인스턴스를 가리킴
    ```
    => 따라서, 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 사용해야 함<br><br>

- 람다를 직렬화하는 일은 하지 말아야함 ( 익명 클래스와 인스턴스도 마찬가지 )

### 람다보다는 메서드 참조를 사용하자

---

람다가 익명 클래스보다 나은 점은 간결한 것인데, 자바에서는 함수 객체를 람다보다 더 간결하게 하는 방법이 존재

⇒ 메서드 참조 <br><br>

```kotlin
// 임의의 키와 Integer 값의 매핑을 관리하는 코드 중 일부
// 키가 맵에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값을 증가시킴

map.merge(key, 1, (count, incr) -> count + incr);
```

merge 메서드는 키, 값, 함수를 인수로 받으며, 주어진 키가 맵 안에 아직 없다면 주어진 키, 값 쌍을 그대로 저장하고, 키가 이미 있다면 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로 현재 값을 덮어씀

즉, 맵에 키, 함수의 결과 쌍을 저장<br><br>

하지만, 위 코드에서 count와 incr는 단순히 합을 반환하는 역할만을 하며 공간을 차지하므로 Integer 클래스의 sum 정적 메서드를 사용하여 람다 대신 이 메서드의 참조를 전달하면 더 간결해짐

```kotlin
map.merge(key, 1, Integer::sum)
```
<br>

람다를 메서드 참조로 변경할 수 있다면 대체로 변경하는 것을 추천하지만, 항상 그런 것은 아니므로 잘 비교하여 사용하자<br><br>

**메서드 참조의 유형 5가지**

1. 정적 메서드를 가리키는 메서드 참조
    
    ⇒ 앞에서 사용하던 방식<br><br>
    

  2, 3. 인스턴스 메서드를 참조하는 유형 2가지

1. 수신 객체 ( 참조 대상 인스턴스 )를 특정하는 한정적 인스턴스 메서드 참조
    
    한정적 참조는 근본적으로 정적 참조와 비슷
    
    ⇒ 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 동일<br><br>
    
2. 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
    
    비한정적 참조에서는 함수 객체를 적용하는 시점에 수신 객체를 알려줌
    
    이를 위해, 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따름
    
    비한정적 참조는 주로 스트림 파이프라인에서의 매핑과 필터 함수에 사용됨<br><br>
    

   4, 5. 클래스 생성자를 가리키는 메서드 참조와 배열 생성자를 가리키는 메서드 참조<br><br>

생성자 참조는 팩터리 객체로 사용됨

| 메서드 참조 유형 | 예 | 같은 기능을 하는 람다 |
| --- | --- | --- |
| 정적 | Integer::parseInt | str → Integer.parseInt(str) |
| 한정적 ( 인스턴스 ) | Instant.now()::isAfter | Instant then = Instant.now();
t → then.isAfter(t) |
| 비한정적 ( 인스턴스 ) | String::toLowerCase | str → str.toLowerCase() |
| 클래스 생성자 | TreeMap<K, V>::new | () → new TreeMap<K, V>() |
| 배열 생성자 | int[]::new | len → new int[len] |
