`객체를 만들어야할 때와 만들지 말아야 할 때, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법`

`, 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 법을 다룹니다.`

### 생성자 대신 정적 팩터리 메서드를 고려하자

---

클래스는 public 생성자 대신 정적 팩터리 메서드를 제공할 수 있습니다.

```kotlin
// boolean 기본 타입을 받아 박싱 클래스를 반환하는 간단한 예

public static Boolean valueOf(boolean b) {
	return b ? Boolean.TRUE : Boolean.False;
}
```

**정적 팩터리 메서드의 장점**

1. 이름을 가질 수 있음
    
    `시그니처가 같은 생성자가 여러 개 필요하다면, 이를 정적 팩터리 메서드로 바꾸고 각 역할에 맞는 적절한 이름을 작성하는 것이 좋음`
    
    > 시그니처 : 클래스에서 메서드나 생성자를 식별하는 정보로, 보통 이름 + 매개변수 타입의 조합을 의미
    > 

1. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 됨
    
    `같은 값을 가진 불변 객체는 미리 만들어 놓고 재사용 해도 되기 때문에, 정적 팩터리 메서드를 활용해 미리 만들어둔 인스턴스를 반환하거나, 한 번 생성한 객체를 캐싱해서 돌려줄 수 있다는 의미`
    
    ```kotlin
    public class Color {
        private final int red, green, blue;
    
        private static final Color BLACK = new Color(0, 0, 0);
    
    		// 정적 팩터리 메서드
    		// 미리 만들어진 불변 객체를 반환
        public static Color black() {
            return BLACK;
        }
    }
    ```
    
    즉, 반복되는 요청에 같은 객체를 반환해야 한다면 위 방식처럼 사용할 수 있는 것
    

1. 선언된 반환 타입보다 더 구체적인 객체( 하위 클래스, 구현 클래스 )를 만들어서 반환할 수 있음
    
    ⇒ 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 유연성이 존재
    
    ⇒ API를 만들 때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지 가능
    
    ```kotlin
    interface Animal {
        void speak();
    }
    
    class Dog implements Animal {
        public void speak() {
            System.out.println("멍멍!");
        }
    }
    
    class Cat implements Animal {
        public void speak() {
            System.out.println("야옹~");
        }
    }
    
    class AnimalFactory {
        public static Animal getAnimal(String type) {
            if (type.equals("dog")) return new Dog(); // Animal의 하위 타입 반환
            else return new Cat();                      
        }
    }
    ```
    
2. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음
    
    반환 타입의 하위 타입이기만 하면 어떤 클래스를 반환하든 상관이 없음
    
    다양한 구현체를 하나의 인터페이스로 감쌀 수 있으며, 클라이언트는 하위 타입 클래스의 존재를 몰라도 됨
    

1. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨
    
    팩터리 메서드는 “인터페이스나 상위 타입”만 반환하도록 정의해두고, 실제로 어떤 클래스 객체를 반환할지는 나중에 결정하거나 외부에서 주입할 수 있음
    
    즉, 메서드를 만들 때는 구체적인 구현 클래스 없이도 설계 가능하고  나중에 필요할 때 클래스를 만들어 붙이면 된다는 뜻
    
    ```kotlin
    public interface Message {
        void send();
    }
    
    public class MessageFactory {
        public static Message getMessage() {
        
            // 아직 어떤 구현체를 반환할지는 정하지 않음
            throw new UnsupportedOperationException("아직 구현 안됨");
        }
    }
    ```
    

구현체가 없어도 인터페이스만으로 구조 설계 가능하고, 클래스 없이도 API 먼저 설계 가능 → 구현은 나중에 추가

**정적 팩터리 메서드의 단점**

1. 상속을 하려면 public이나 protected 생성자가 필요하니 생성자를 제공하지 않고 정적 팩터리 메서드만 제공하면 하위 클래스를 생성할 수 없음

상속을 하려면 반드시 부모 생성자를 호출해야 하므로, 상위 클래스의 생성자가 public이나 protected가 아니면 안됨

⇒ 자바에서 하위 클래스의 객체를 생성하려면, 반드시 상위 클래스의 생성자를 먼저 호출해야함

1. 정적 팩터리 메서드는 프로그래머가 찾기 힘듦
    
    정적 팩터리 메서드는 이름이 자유롭기 때문에, 개발자가 생성 방법을 직관적으로 알기 어려움
    
    따라서 자바 API에서 팩터리 메서드 작명 컨벤션을 따르는 것이 좋음
    
    - from
        
        다른 타입의 객체를 1개 받아서 , 그 값을 기반으로 자신 타입의 인스턴스 반환
        
        ex) Date d = Date.from(instance)
        
    - of
        
        여러 개의 매개변수를 받아서 객체 생성
        
        ex) List<String> names = List.of("Kim", "Lee", "Park");
        
    - valueOf
        
        from, of보다 더 구체적인 변환 메서드 느낌, 보통 기본 타입 → 객체 타입 변환할 때 사용
        
        ex) BigInteger = prime = BigInteger.valueOf(Integer.MAX_VALUE);
        
    
    - instance or getInstance
        
        매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않음
        
        ex) StackWalker luke = StackWalker.getInstance(options);
        
    - create or newInstance
        
        instance or getInstance와 같지만 매번 새로운 인스턴스를 생성해 반환함을 보장
        
        ex) Object newArray = Array.newInstance(classObject, arrayLen);
        
    
    - getType
        
        getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용
        
        ‘Type’은 팩터리 메서드가 반환할 객체의 타입임
        
        ex) FileStore fs = Files.getFileStore(path)
        
    - newType
        
        newInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용
        
        ‘Type’은 팩터리 메서드가 반환할 객체의 타입임
        
    

### 생성자에 매개변수가 많다면 빌더를 고려하자

---

정적 팩터리와 생성자는 선택적 매개변수가 많을 경우 적절히 대응하기 어렵다는 점이 존재

만약 여러 매개변수를 받는 생성자가 있고, 대다수의 항목의 값이 고정된 값일 때 대부분 점층적 생성자 패턴을 사용함

> 점층적 생성자  : 필수 매개변수만 받는 생성자, 필수 매개변수와 선택적 매개변수 1개를 받는 생성자 …
> 

이러한 클래스의 인스턴스를 만들기 위해서는 원하는 생성자를 골라서 호출하면 되지만, 원하지 않는 매개변수까지 포함하기도 쉽고, 매개변수의 수가 많다면 코드를 작성하기도 읽기도 어렵게 됨

**이렇게 선택적 매개변수가 많을 때의 해결 방법**

- ~~자바 빈즈 패턴~~
    
    매개변수가 없는 생성자로 객체를 만든 후 setter를 통해 원하는 매개변수의 값을 설정하는 방식
    
    하지만, 자바 빈즈 패턴은 객체 하나를 만드려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 초기화되기 전에 외부에서 접근이 가능하기 때문에, 일관성 없는 상태로 남을 가능성이 있음
    
    또한, 세터를 필수로 사용하는 자바 빈즈 패턴은 클래스의 필드 값을 나중에 설정하거나 변경하는 구조이기 때문에, 필드를 final로 만들 수 없고 이렇기에 객체를 불변으로 만들 수 없음
    

- 빌더 패턴
    
    필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자를 호출하여 빌더 객체를 얻은 다음 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수를 설정
    
    ```kotlin
    public class Test {
        private final int a;
        private final int b;
        private final int c;
        private final int d;
        private final int e;
    
        private Test(Builder builder) {
            this.a = builder.a;
            this.b = builder.b;
            this.c = builder.c;
            this.d = builder.d;
            this.e = builder.e;
        }
    
        public static class Builder {
            // 필수 매개변수
            private final int a;
            private final int b;
    
            // 선택 매개변수 (초기값 지정)
            private int c = 0;
            private int d = 0;
            private int e = 0;
    
            public Builder(int a, int b) {
                this.a = a;
                this.b = b;
            }
    
            public Builder c(int value) {
                this.c = value;
                return this;
            }
    
            public Builder d(int value) {
                this.d = value;
                return this;
            }
    
            public Builder e(int value) {
                this.e = value;
                return this;
            }
    
            public Test build() {
                return new Test(this);
            }
        }
    }
    ```
    
    Test 클래스는 불변이고, 모든 매개변수의 기본 값들을 한 곳에 모아두었으며, 빌더의 세터 메서드들은 빌더 자신을 반환하기 때문에 연쇄적으로 호출할 수 있음
    
    ⇒ 메서드 연쇄, 플루어트 API
    
    > 사용 : Test test = new Test.Builder(240, 8).c(100).d(30).e(24).build()
    > 
    
    ⇒ 사실 직접 구현 안하고 그냥 `@Builder 어노테이션`을 사용하기만 하면 되는 것이긴 함
    

### private 생성자나 열거 타입으로 싱글턴임을 보증하자

---

`싱글턴 : 인스턴스를 오직 하나만 생성할 수 있는 클래스를 의미`

`싱글턴 패턴 : 클래스의 인스턴스를 단 하나만 생성해서, 전역적으로 공유하고 싶을 때 사용하는 패턴`

ex) 함수와 같은 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트

**싱글턴으로 만드는 방식**

1. 생성자를 private로 만들고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 마련
    
    ```kotlin
    public class Test{
    
    	private Test(){...}
    	
    	// 자기 자신 클래스 내부에서는 호출 가능
    	public static final Elvis INSTANCE = new Test();
    	
    	public void leaveTheBuilding() {...}
    }
    ```
    

private 생성자는 public static final 필드인 Test.INSTANCE를 처음 사용할 때 딱 한 번 호출됨

public이나 protected 생성자가 없으므로 Test 클래스가 초기화 될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장됨

1. 정적 팩터리 메서드를 public static 멤버로 제공하는 것
    
    ```kotlin
    public class Test{
    
    	private Test(){...}
    	
    	// 자기 자신 클래스 내부에서는 호출 가능
    	public static final Elvis INSTANCE = new Test();
    	
    	public static Test getInstance() {
    		return INSTANCE;
    	}
    	
    	public void leaveTheBuilding() {...}
    }
    ```
    
    정적 팩터리 메서드를 사용하여 싱글턴을 만들 때 장점
    
    - API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다는 점
        
        ```kotlin
        public static Test getInstance() {
        		return INSTANCE;
        }
        
        // 싱글턴을 반환하는 getInstance() 메서드를 그냥 싱글턴이 아닌 객체를 반환하게 변경할 수 있음
        
        public static Test getInstance() {
        		return new Test();
        }
        ```
        
    
    즉, 공개된 API는 유지되지만, 내부 구현은 바뀜
    

### 인스턴스화를 막기 위해서는 private 생성자를 사용

---

때때로 정적 메서드아 정적 필드만을 가지는 클래스를 만들 때 사용

`java.lang.Math` , `java.util.Collections` 등에서 사용

```kotlin
Math.abs(-5);    // 정적 메서드 사용
Math.max(1, 10); // 정적 메서드 사용

// 아래처럼 사용할 필요는 없으니, 생성자를 private로 만들어서 인스턴스를 만들지 못하게 함
Math m = new Math();
```

```kotlin
public class Test {
	private Test() {
		throw new AssertionError();
	}
	...
}
```

명시적으로 생성자가 private 이기 때문에 클래스 바깥에서는 접근할 수 없으며, 꼭 error를 던질 필요는 없지만

, 혹시라도 클래스 안에서 실수로라도 생성자를 호출하지 않게 해줌

즉, 어떤 환경에서도 클래스가 인스턴스화 되는 것을 막아줌

또한, 이러한 방식은 상속을 불가능하게 하는 효과도 있음 → 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하지만, private로 선언했기에 하위 클래스가 상위 클래스의 생성자에 접근할 수 없기 때문
