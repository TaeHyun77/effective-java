### raw 타입은 사용하지 말자

---

> 제네릭 클래스 :  타입 매개변수가 쓰인 클래스
> 

> 제네릭 인터페이스 : 타입 매개변수가 쓰인 인페이스
> 

`이 둘을 통틀어 제네릭 타입이라 칭함`

Ex ) List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받음<br><br>

**각각의 제네릭 타입은 일련의 매개변수화 타입을 정의**

⇒ 먼저 클래스 이름이 나오고, 이어서 꺾쇠 괄호 안에 실제 타입 매개변수를 나열

Ex ) List<String>은 원소의 타입이 String인 리스트를 의미하는 매개변수화 타입<br><br>

**제네릭 타입을 하나 정의하면 이에 딸린 raw 타입도 함께 정의됨**

> raw 타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때
> 

Ex ) List<String>의 raw 타입 : List<br><br>

raw 타입은 타입 선언에서 제네릭 정보를 사용하지 않아 모든 제네릭 타입 정보가 제거된 것처럼 동작하며, 이는 제네릭 도입 이전의 코드와의 호환성을 유지하기 위해 제공된 기능임

```kotlin
// 예시: Stamp 인스턴스만 취급
private final Collection stamps = ...;

이 코드는 실수로 Stamp 대신 다른 것을 넣어도 아무 오류 없이 컴파일되고 실행됨
이후 런타임에서 Stamp 타입으로 형 변환을 할 때 오류가 발생하게 됨
```

⇒ raw 타입은 타입 안정성을 보장하지 못하고, 언어적 차원에서 막지는 않지만 절대로 사용해서는 안됨

⇒ raw 타입을 사용하게 되면 제네릭이 주는 안전성과 표현력을 잃게 됨<br><br>

위의 코드를 아래와 같이 수정하면 컴파일러가 stamps에 Stamp의 인스턴스만 넣어야 함을 인지하므로 만약, Stamp 인스턴스 대신 다른 것을 넣는다면 컴파일 에러가 발생하게 됨

```kotlin
private final Collection<Stamp> stamps = ...;
```
<br>

**TMI ) 그럼 왜 raw 타입을 만들어 놓은걸까** 

자바가 제네릭을 사용하기 전 제네릭 없이 작성한 수많은 코드와 제네릭을 사용한  새로운 코드에 호환성을 위함

List와 같은 raw 타입은 사용해서는 안되지만 List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 OK<br><br>

**List와 매개변수화 타입은 List<Object>의 차이는 무엇일까 ?**

⇒ List는 제네릭 타입을 완전히 제거한 것이고 List<Object>는 모든 타입을 허용한다는 의미를 컴파일러에게 명확히 전달한 것이기 때문<br><br>

**List<String>은 List raw 타입에는 넘길 수 있지만 List<Object>에는 넘길 수 없음**

⇒ 제네릭 하위 타입 규칙 때문

즉, List<String>은 List raw 타입의 하위 타입이지만, List<Object>의 하위 타입은 아님<br><br>

**제네릭은 기본적으로 불공변적으로 설계**

> 불공변성 :  A가 B의 하위 타입이더라도, List<A>는 List<B>의 하위 타입이 아님
> 

> 공변성 : A가 B의 하위 타입이면, List<A>도 List<B>의 하위 타입 ⇒ 배열이 이에 해당
> 

```kotlin
String str = "hello";
Object obj = str;  // 가능 ( String은 Object의 하위 타입이기 때문 )

List<String> strings = new ArrayList<>();
List<Object> objects = strings; // 컴파일 오류

만약의 위의 오류 코드가 허용된다면 ??
objects.add(123); // Integer 추가 가능
String s = strings.get(0); // Integer → 런타임 오류
```

⇒ 타입 안전성을 보장하기 위해 제네릭은 기본적으로 불공변적으로 설계<br><br>

**예시**

```kotlin
public static void main (...) {
	List<String> strings = new ArrayList<>();
	
	unsafeAdd(strings, Integer.valueOf(42));
	String s = strings.get(0);
}

private static void unsafeAdd(List list, Object o) {
	list.add(o)
}
```
<br>

위 코드는 컴파일은 되지만 raw 타입인 List를 사용하여 경고가 발생 

이후, 실행을 하게 되면 strings.get(0)의 결과를 형변환하려 할 때 예외가 발생<br><br>

그럼 만약 List를 매개변수화 타입인 List<Object>로 바꾼다면 ?

컴파일 에러 발생 : `List<String> cannot be converted to List<Object>`

⇒ unsafeAdd의 List 타입에 List<String>을 넣을 수 없기 때문<br><br>

**그러면 원소의 타입을 몰라도 되는 raw 타입을 사용해도 될까 라고 생각할 수도 있음**

```kotlin
// 잘못된 예
static int newElementInCommon(Set s1, Set s2) {
	int result = 0;
	
	for (Object o: s1) 
		if (s2.contains(o1))
			result++;
	
	return result;
}
```

⇒ 이 코드는 동작은 하지만 raw 타입을 사용했기에 안전하지 않음<br><br>

**raw 타입 대신 비한정적 와일드카드 타입을 사용하자 ⭐️**

`제네릭 타입을 사용하고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 때 사용`<br><br>

비한정적 와일드카드 타입을 사용하여 newElementInCommon을 다시 선언

```kotlin
static int newElementInCommon(Set<?> s1, Set<?> s2) {...}
```
<br>

와일드카드 타입은 안전하지만 raw 타입은 안전하지 않음

raw 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽지만

, Collection<?>에는 null 외의 어떤 원소도 넣을 수 없음 → 다른 원소를 넣으려 하면 컴파일 오류 발생<br><br>

⭐️⭐️⭐️

따라서, <?>로 선언한 이유는 메서드 내에서 컬렉션을 읽기 전용으로 만들어 원본 컬렉션을 건드리지 않음을 보장
⇒ 삽입-수정은 불가 , 삭제는 가능<br><br>

위와 같은 제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드 카드 타입을 사용<br><br>

**raw 타입을 쓰지말라는 규칙의 예외**

1. class 리터럴에는 raw 타입을 써야 한다
    
    자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 함
    
    Ex ) List.class, String[] class, int.class는 허용하고 List<String>.class, List<?>.class는 허용 안함<br><br>
    

2. instanceOf 연산자
    
    런타입에는 제네릭 타입 정보가 지워지므로 instanceOf 연산자는 비한정적 와일드카드 타입 외의 매개변수화 타입에는 적용할 수 없으며, raw 타입이든 비한정적 와일드카드 타입이든 instanceOf는 똑같이 동작
    
    ⇒ 비한정적 와일드카드 타입의 꺽쇠 괄호와 물음표는 지저분하므로 차라리 raw 타입을 사용
    
    ```kotlin
    // raw 타입을 사용해도 되는 좋은 예 - instanceOf 연산자
    if (o instanceOf Set) {
    	Set<?> s = (Set<?>) o;
    }
    
    o의 타입이 Set임을 확인한 후 와일드카드 타입인 Set<?>로 형변환 해야함
    ⇒ 이는 검사 형변환이므로 컴파일러 경고가 발생하지 않음
    ```
    <br>
    

**결론**

- raw 타입을 사용하면 런타임 예외가 발생할 수 있으니 사용하면 안됨
    
    ( 제네릭 도입 전 이전 코드와의 호환성을 위해 제공된 것 뿐)
    
- Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드 카드 타입이고, 이들의 raw 타입인 Set은 제네릿 타입에 속하지 않음
- Set<Object>와 Set<?>는 안전하지만, raw 타입인 Set은 안전하지 않음<br><br>

### 비검사 경고를 제거하자

---

제네릭을 사용하게 되면 비검사 형 변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변 인수 타입 경고, 비검사 변환 경고 등의 수많은 컴파일러 경고를 보게 되는데, 이러한 비검사 경고를 쉽게 제거할 수 있음<br><br>

**비검사 형 변환 경고**

```kotlin
Set<Lark> exltation = new HashSet();

HashSet의 타입 매개변수가 지정되지 않아 컴파일러가 타입 안전성을 보장할 수 없다는 경고 발생

new HashSet은 Raw Type이므로 컴파일러는 내부적으로 HashSet을 HashSet<Object>로 취급
하지만, 이를 Set<Lark>로 대입하려고 하니 컴파일러는 Object → Lark 변환이 안전한지 확인할 수 없으므로
비검사 형 변환 경고를 발생
```
<br>

위의 코드를 아래와 같이 다이아몬드 연산자를 통해 컴파일러가 올바른 실제 타입 매개변수를 추론하도록 해야함

```kotlin
Set<Lark> exltation = new HashSet<>();
```
<br>

경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 `@SuppressWarnings(”unchecked”)`를 사용

`@SuppressWarnings` 어노테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 사용할 수 있지만, 항상 가능한 좁은 범위에 적용하자 !

보통은 변수 선언, 아주 짧은 메서드, 혹은 생성자가 될 것인데, 이를 사용하면 심각한 경고를 무시할 수 있으니 절대로 클래스 전체에 적용해서는 안됨

한 줄이 넘는 메서드나 생성자에 달린 `@SuppressWarnings` 어노테이션을 발견하면 지역변수 선언으로 옮기자

⇒ 이를 위해 새로운 지역변수를 선언해야하겠지만 그래도 하는게 좋음

```kotlin
// 경고를 발생시키는 toArray 메서드의 예

private Object[] elements; // 내부 배열
private int size;
    
public <T> T[] toArray(T[] a) {
	if (a.length < size) 
		return (T[]) Arrays.copyOf(elements, size, a.getClass());
	
	System.arrayCopy(elements, 0, a, 0, size);
	if (a.length > size) 
		a[size] = null;
	return a;
}

Arrays.copyOf의 첫 번째 인자는 T[]를 받지만 Object[]를 넘기에 컴파일 시 경고 발생
```
<br>

`@SuppressWarnings` 어노테이션은 선언에만 사용할 수 있기에 return 문에서는 `@SuppressWarnings` 을 사용하는 것은 불가능하며, 메세드 전체에 사용한다면 범위가 넓어지므로 반환값을 담을 지역변수를 선언하고 이 변수에 사용하는 것이 좋음

```kotlin
// 올바른 toArray 메서드의 예
public <T> T[] toArray(T[] a) {
	if (a.length < size) 
		@SuppressWarnings(”unchecked”) T[] result =  
			(T[]) Arrays.copyOf(elements, size, a.getClass());
		
		return result
	
	System.arrayCopy(elements, 0, a, 0, size);
	if (a.length > size) 
		a[size] = null;
		
	return a;
}

깔끔히 컴파일되며, 비검사 경고를 숨기는 범위도 최소가 됨
```
<br>

`@SuppressWarnings(”unchecked”)` 어노테이션을 사용한다면 경고를 무시해도 안전한 이유를 항상 주석으로 남겨놔야 함<br><br>

### 배열 보단 리스트를 사용하자

---

`배열과 리스트에는 큰 차이가 존재`<br><br>

1. 배열은 공변하다.
    - 배열은 공변하다 ( 공변 : 함께 변하다 )
    - 리스트는 비공변하다. ( 비공변 : 함께 변하지 않는다 )<br><br>
    
    > 공변성 : sub가 super의 하위 타입이라면 sub[]는 super[]의 하위 타입이 된다
    > 
    
    > 비공변성 : List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다
    >

    <br><br>
    
    이렇게 보면 배열 쪽이 더 좋다고 생각할 수도 있지만, 문제가 되는 쪽은 배열임
    
    ```kotlin
    // 런타임에 실패
    Object[] objectArray = new Long[1];
    objectArray[0] = "타입이 달라 넣을 수 없음" // ArrayStoredException
    
    // 컴파일조차 되지 않음
    List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입
    ```
    <br>
    
    오류가 발생하는 시기가 배열은 런타임 때 알게 되지만 리스트를 사용하면 바로 알 수 있음<br><br>
    

2. 배열은 실체화가 됨
    
    배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인하는데, 따라서 Long 배열에 String을 넣으려하면 ArrayStoredException 예외가 발생
    
    하지만, 제네릭은 타입 정보가 런타임에는 소거되므로 원소 타입을 컴파일 타입에만 검사하며 런타임에는 알수조차 없음
    
    ⇒ 컴파일 후에는 원래 타입 정보가 제거되어 Raw Type으로 변환되고, 타입 검사는 컴파일러가 생성한 캐스트 코드에서만 수행됨<br><br>
    
    이러한 차이 때문에 배열과 제네릭은 잘 어우러지지 못함
    
    ⇒ 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없음
    
    Ex ) `new List<E>[]`, `new List<String>[]`, `new E[]` 식으로 작성하면 컴파일 오류 발생<br><br>
    
    **제네릭 배열을 만들지 못하는 이유는 무엇일까 ?**
    
    `타입 안전하지 않기 때문`<br><br>
    
    이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCast..가 발생할 수 있음
    
    런타임에 ClassCast…이 발생하는 것을 막아주겠다는 제네릭 타입 시스템의 목적에 어긋남
    
    ```kotlin
    // 예시
    List<String>[] StringLists = new List<String>[1]; // 1
    List<Integer> intList = List.of(42); // 2
    Object[] objects = stringLists; // 3
    
    objects[0] = intList; // 4
    String s = stringLists[0].get(0); // 5
    ```
    <br>
    
    만약 1이 허용된다고 했을 때, 배열은 공변이니 3이 허용되게 되고 4에서 제네릭은 런타임시 타입이 소거되므로 이 역시 성공하게 됨 ( 런타임 시 List[]가 되어버림 )
    
    이때 5에서 컴파일러는 꺼낸 원소를 자동으로 String으로 형변환 하려 하지만, 이 원소는 Integer이므로 런타임에 ClassException이 발생
    
    ⇒ 이를 방지하려면 제네릭 배열이 생성되지 않도록 컴파일 오류를 발생시켜야 함<br><br>
    
    > 실체화 불가 타입 : `E`, `List<E>`, `List<String>`과 같은 타입
    > 
    
    ⇒ 실체화 되지 않아 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입
    
    ⇒ 소거 매커니즘 때문에 매개변수화 타입 중 실체화 될 수 있는 타입은 List<?>와 Map<?,?>와 같은 비한정적 와일드카드 타입 뿐임 ⇒ 하지만, 거의 안씀<br><br>
    
    **배열에 제네릭을 넣을 수 없기에 불편한 상황도 존재**
    
    예를 들어, 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능
    
    ⇒ 제네릭은 타입 소거 방식으로 동작하므로 특정 타입의 배열을 반환할 방법이 없음
    
    ⇒ 따라서 호출하는 쪽에서 타입을 알려주는 배열을 전달받아 그 배열을 채워서 반환하는 방식을 사용해야 함
    
    ```kotlin
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
        
            // 전달받은 배열 타입 a.getClass()를 기반으로 새 배열 생성
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    
        // 전달받은 배열이 충분히 크면 기존 배열에 복사
        System.arraycopy(elementData, 0, a, 0, size);
    
        if (a.length > size) a[size] = null;
    
        return a;
    }
    
    --- toArray 사용 예시
    
    List<String> list = new ArrayList<>();
    	list.add("사과");
    	list.add("바나나");
    	list.add("체리");
    
    	// toArray 사용 ( 제네릭 타입 유지 )
    	// new String[0]은 런타임에 실제 리스트 크기에 맞춰 동적으로 배열을 생성해줌
    	String[] array = list.toArray(new String[0]);
    ```
    <br>
    
    제네릭 타입과 가변 인수 메서드를 함께 사용하면 경고를 발생
    
    가변 인수 메서드를 호출할 때마다 가변 인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가능 타입이라면 경고가 발생
    
    즉, 배열에 실체화 불가능 타입을 담을 수 없기에 발생하는 에러
    
    ⇒ `@SafeVarargs` 어노테이션으로 대처할 수 있음<br><br>
    
    ```kotlin
    // 생성자에서 컬렉션을 받는 제네릭을 사용하지 않은 버전
    public class Chooser {
    	private final Object[] choiceArray;
    	
    	public Chooser(Collection choices) {
    		choiceArray = choices.toArray();
    	}
    	
    	public Object choose() {
    		Random rnd = ThreadLocalRandom.current();
    		return choiceArray[rnd.nextInt(choiceArray.length)];
    	}
    }
    
    choose 메서드를 호출할 때마다 반환된 Object를 원하는 타입으로 형변환해야 함
    만약, 타입이 다른 원소가 있다면 런타임에 형변환 오류가 발생하게 됨
    ```
    <br>
    
    ```kotlin
    // 제네릭을 사용한 버전
    public class Chooser<T> {
    	private final T[] choiceArray;
    	
    	public Chooser(Collection<T> choices) {
    		choiceArray = choices.toArray();
    	}
    	
    	public Object choose() {
    		...
    	}
    }
    
    Object[]인 choices.toArray()를 T[]인 choiceArray에 대입할 수 없다는 오류 발생
    
    따라서 다음과 같이 변경 (T[]) choices.toArray();
    ⇒ 이 역시 경고 발생
    ⇒ T가 정확히 무슨 타입인지 컴파일 시점에 알 수 없기 때문에, 이 형변환이 런타임에 안전할지 보장할 수 없다는 경고
      ( 런타임에는 자바가 T를 유지하지 않고, 그냥 Object 취급 )
      
    ⇒ 컴파일러가 안전을 보장하지 못할 뿐 안전을 확신한다면 @SafeVarargs을 통해 경고를 숨기자
    ⇒ 애초에 아래와 같이 경고의 원인을 제거하는 것이 낫긴 하지만 .. ..
    ```
    <br>
    

비검사 형변환 경고를 아예 제거하려면 배열 대신 리스트를 사용하면 됨

```kotlin
public class Chooser<T> {
	private final List<T> choiceList;
	
	public Chooser(Collection<T> choices) {
		choiceList = new ArrayList<>(choices);
	}
	
	public Object choose() {
		Random rnd = ThreadLocalRandom.current();
		return choiceList.get(rnd.nextInt(choiceList.size()));
	}
}

⇒ 런타임에 ClassEx.. 을 발생시킬 가능성이 없으니 이렇게 변경할 가치가 있음
```
