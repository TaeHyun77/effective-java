### raw 타입은 사용하지 말자

---

> 제네릭 클래스 :  타입 매개변수가 쓰인 클래스
> 

> 제네릭 인터페이스 : 타입 매개변수가 쓰인 인페이스
> 

`이 둘을 통틀어 제네릭 타입이라 칭함`

Ex ) List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받음<br><br>

**각각의 제네릭 타입은 일련의 매개변수화 타입을 정의**

⇒ 먼저 클래스 이름이 나오고, 이어서 꺾쇠 괄호 안에 실제 타입 매개변수를 나열

Ex ) List<String>은 원소의 타입이 String인 리스트를 의미하는 매개변수화 타입<br><br>

**제네릭 타입을 하나 정의하면 이에 딸린 raw 타입도 함께 정의됨**

> raw 타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때
> 

Ex ) List<String>의 raw 타입 : List<br><br>

raw 타입은 타입 선언에서 제네릭 정보를 사용하지 않아 모든 제네릭 타입 정보가 제거된 것처럼 동작하며, 이는 제네릭 도입 이전의 코드와의 호환성을 유지하기 위해 제공된 기능임

```kotlin
// 예시: Stamp 인스턴스만 취급
private final Collection stamps = ...;

이 코드는 실수로 Stamp 대신 다른 것을 넣어도 아무 오류 없이 컴파일되고 실행됨
이후 런타임에서 Stamp 타입으로 형 변환을 할 때 오류가 발생하게 됨
```

⇒ raw 타입은 타입 안정성을 보장하지 못하고, 언어적 차원에서 막지는 않지만 절대로 사용해서는 안됨

⇒ raw 타입을 사용하게 되면 제네릭이 주는 안전성과 표현력을 잃게 됨<br><br>

위의 코드를 아래와 같이 수정하면 컴파일러가 stamps에 Stamp의 인스턴스만 넣어야 함을 인지하므로 만약, Stamp 인스턴스 대신 다른 것을 넣는다면 컴파일 에러가 발생하게 됨

```kotlin
private final Collection<Stamp> stamps = ...;
```
<br>

**TMI ) 그럼 왜 raw 타입을 만들어 놓은걸까** 

자바가 제네릭을 사용하기 전 제네릭 없이 작성한 수많은 코드와 제네릭을 사용한  새로운 코드에 호환성을 위함

List와 같은 raw 타입은 사용해서는 안되지만 List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 OK<br><br>

**List와 매개변수화 타입은 List<Object>의 차이는 무엇일까 ?**

⇒ List는 제네릭 타입을 완전히 제거한 것이고 List<Object>는 모든 타입을 허용한다는 의미를 컴파일러에게 명확히 전달한 것이기 때문<br><br>

**List<String>은 List raw 타입에는 넘길 수 있지만 List<Object>에는 넘길 수 없음**

⇒ 제네릭 하위 타입 규칙 때문

즉, List<String>은 List raw 타입의 하위 타입이지만, List<Object>의 하위 타입은 아님<br><br>

**제네릭은 기본적으로 불공변적으로 설계**

> 불공변성 :  A가 B의 하위 타입이더라도, List<A>는 List<B>의 하위 타입이 아님
> 

> 공변성 : A가 B의 하위 타입이면, List<A>도 List<B>의 하위 타입 ⇒ 배열이 이에 해당
> 

```kotlin
String str = "hello";
Object obj = str;  // 가능 ( String은 Object의 하위 타입이기 때문 )

List<String> strings = new ArrayList<>();
List<Object> objects = strings; // 컴파일 오류

만약의 위의 오류 코드가 허용된다면 ??
objects.add(123); // Integer 추가 가능
String s = strings.get(0); // Integer → 런타임 오류
```

⇒ 타입 안전성을 보장하기 위해 제네릭은 기본적으로 불공변적으로 설계<br><br>

**예시**

```kotlin
public static void main (...) {
	List<String> strings = new ArrayList<>();
	
	unsafeAdd(strings, Integer.valueOf(42));
	String s = strings.get(0);
}

private static void unsafeAdd(List list, Object o) {
	list.add(o)
}
```
<br>

위 코드는 컴파일은 되지만 raw 타입인 List를 사용하여 경고가 발생 

이후, 실행을 하게 되면 strings.get(0)의 결과를 형변환하려 할 때 예외가 발생<br><br>

그럼 만약 List를 매개변수화 타입인 List<Object>로 바꾼다면 ?

컴파일 에러 발생 : `List<String> cannot be converted to List<Object>`

⇒ unsafeAdd의 List 타입에 List<String>을 넣을 수 없기 때문<br><br>

**그러면 원소의 타입을 몰라도 되는 raw 타입을 사용해도 될까 라고 생각할 수도 있음**

```kotlin
// 잘못된 예
static int newElementInCommon(Set s1, Set s2) {
	int result = 0;
	
	for (Object o: s1) 
		if (s2.contains(o1))
			result++;
	
	return result;
}
```

⇒ 이 코드는 동작은 하지만 raw 타입을 사용했기에 안전하지 않음<br><br>

**raw 타입 대신 비한정적 와일드카드 타입을 사용하자 ⭐️**

`제네릭 타입을 사용하고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 때 사용`<br><br>

비한정적 와일드카드 타입을 사용하여 newElementInCommon을 다시 선언

```kotlin
static int newElementInCommon(Set<?> s1, Set<?> s2) {...}
```
<br>

와일드카드 타입은 안전하지만 raw 타입은 안전하지 않음

raw 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽지만

, Collection<?>에는 null 외의 어떤 원소도 넣을 수 없음 → 다른 원소를 넣으려 하면 컴파일 오류 발생<br><br>

⭐️⭐️⭐️

따라서, <?>로 선언한 이유는 메서드 내에서 컬렉션을 읽기 전용으로 만들어 원본 컬렉션을 건드리지 않음을 보장
⇒ 삽입-수정은 불가 , 삭제는 가능<br><br>

위와 같은 제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드 카드 타입을 사용<br><br>

**raw 타입을 쓰지말라는 규칙의 예외**

1. class 리터럴에는 raw 타입을 써야 한다
    
    자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 함
    
    Ex ) List.class, String[] class, int.class는 허용하고 List<String>.class, List<?>.class는 허용 안함<br><br>
    

2. instanceOf 연산자
    
    런타입에는 제네릭 타입 정보가 지워지므로 instanceOf 연산자는 비한정적 와일드카드 타입 외의 매개변수화 타입에는 적용할 수 없으며, raw 타입이든 비한정적 와일드카드 타입이든 instanceOf는 똑같이 동작
    
    ⇒ 비한정적 와일드카드 타입의 꺽쇠 괄호와 물음표는 지저분하므로 차라리 raw 타입을 사용
    
    ```kotlin
    // raw 타입을 사용해도 되는 좋은 예 - instanceOf 연산자
    if (o instanceOf Set) {
    	Set<?> s = (Set<?>) o;
    }
    
    o의 타입이 Set임을 확인한 후 와일드카드 타입인 Set<?>로 형변환 해야함
    ⇒ 이는 검사 형변환이므로 컴파일러 경고가 발생하지 않음
    ```
    <br>
    

**결론**

- raw 타입을 사용하면 런타임 예외가 발생할 수 있으니 사용하면 안됨
    
    ( 제네릭 도입 전 이전 코드와의 호환성을 위해 제공된 것 뿐)
    
- Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드 카드 타입이고, 이들의 raw 타입인 Set은 제네릿 타입에 속하지 않음
- Set<Object>와 Set<?>는 안전하지만, raw 타입인 Set은 안전하지 않음<br><br>

### 비검사 경고를 제거하자

---

제네릭을 사용하게 되면 비검사 형 변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변 인수 타입 경고, 비검사 변환 경고 등의 수많은 컴파일러 경고를 보게 되는데, 이러한 비검사 경고를 쉽게 제거할 수 있음<br><br>

**비검사 형 변환 경고**

```kotlin
Set<Lark> exltation = new HashSet();

HashSet의 타입 매개변수가 지정되지 않아 컴파일러가 타입 안전성을 보장할 수 없다는 경고 발생

new HashSet은 Raw Type이므로 컴파일러는 내부적으로 HashSet을 HashSet<Object>로 취급
하지만, 이를 Set<Lark>로 대입하려고 하니 컴파일러는 Object → Lark 변환이 안전한지 확인할 수 없으므로
비검사 형 변환 경고를 발생
```
<br>

위의 코드를 아래와 같이 다이아몬드 연산자를 통해 컴파일러가 올바른 실제 타입 매개변수를 추론하도록 해야함

```kotlin
Set<Lark> exltation = new HashSet<>();
```
<br>

경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 `@SuppressWarnings(”unchecked”)`를 사용

`@SuppressWarnings` 어노테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 사용할 수 있지만, 항상 가능한 좁은 범위에 적용하자 !

보통은 변수 선언, 아주 짧은 메서드, 혹은 생성자가 될 것인데, 이를 사용하면 심각한 경고를 무시할 수 있으니 절대로 클래스 전체에 적용해서는 안됨

한 줄이 넘는 메서드나 생성자에 달린 `@SuppressWarnings` 어노테이션을 발견하면 지역변수 선언으로 옮기자

⇒ 이를 위해 새로운 지역변수를 선언해야하겠지만 그래도 하는게 좋음

```kotlin
// 경고를 발생시키는 toArray 메서드의 예

private Object[] elements; // 내부 배열
private int size;
    
public <T> T[] toArray(T[] a) {
	if (a.length < size) 
		return (T[]) Arrays.copyOf(elements, size, a.getClass());
	
	System.arrayCopy(elements, 0, a, 0, size);
	if (a.length > size) 
		a[size] = null;
	return a;
}

Arrays.copyOf의 첫 번째 인자는 T[]를 받지만 Object[]를 넘기에 컴파일 시 경고 발생
```
<br>

`@SuppressWarnings` 어노테이션은 선언에만 사용할 수 있기에 return 문에서는 `@SuppressWarnings` 을 사용하는 것은 불가능하며, 메세드 전체에 사용한다면 범위가 넓어지므로 반환값을 담을 지역변수를 선언하고 이 변수에 사용하는 것이 좋음

```kotlin
// 올바른 toArray 메서드의 예
public <T> T[] toArray(T[] a) {
	if (a.length < size) 
		@SuppressWarnings(”unchecked”) T[] result =  
			(T[]) Arrays.copyOf(elements, size, a.getClass());
		
		return result
	
	System.arrayCopy(elements, 0, a, 0, size);
	if (a.length > size) 
		a[size] = null;
		
	return a;
}

깔끔히 컴파일되며, 비검사 경고를 숨기는 범위도 최소가 됨
```
<br>

`@SuppressWarnings(”unchecked”)` 어노테이션을 사용한다면 경고를 무시해도 안전한 이유를 항상 주석으로 남겨놔야 함<br><br>

### 배열 보단 리스트를 사용하자

---

`배열과 리스트에는 큰 차이가 존재`<br><br>

1. 배열은 공변하다.
    - 배열은 공변하다 ( 공변 : 함께 변하다 )
    - 리스트는 비공변하다. ( 비공변 : 함께 변하지 않는다 )<br><br>
    
    > 공변성 : sub가 super의 하위 타입이라면 sub[]는 super[]의 하위 타입이 된다
    > 
    
    > 비공변성 : List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다
    >

    <br><br>
    
    이렇게 보면 배열 쪽이 더 좋다고 생각할 수도 있지만, 문제가 되는 쪽은 배열임
    
    ```kotlin
    // 런타임에 실패
    Object[] objectArray = new Long[1];
    objectArray[0] = "타입이 달라 넣을 수 없음" // ArrayStoredException
    
    // 컴파일조차 되지 않음
    List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입
    ```
    <br>
    
    오류가 발생하는 시기가 배열은 런타임 때 알게 되지만 리스트를 사용하면 바로 알 수 있음<br><br>
    

2. 배열은 실체화가 됨
    
    배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인하는데, 따라서 Long 배열에 String을 넣으려하면 ArrayStoredException 예외가 발생
    
    하지만, 제네릭은 타입 정보가 런타임에는 소거되므로 원소 타입을 컴파일 타입에만 검사하며 런타임에는 알수조차 없음
    
    ⇒ 컴파일 후에는 원래 타입 정보가 제거되어 Raw Type으로 변환되고, 타입 검사는 컴파일러가 생성한 캐스트 코드에서만 수행됨<br><br>
    
    이러한 차이 때문에 배열과 제네릭은 잘 어우러지지 못함
    
    ⇒ 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없음
    
    Ex ) `new List<E>[]`, `new List<String>[]`, `new E[]` 식으로 작성하면 컴파일 오류 발생<br><br>
    
    **제네릭 배열을 만들지 못하는 이유는 무엇일까 ?**
    
    `타입 안전하지 않기 때문`<br><br>
    
    이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCast..가 발생할 수 있음
    
    런타임에 ClassCast…이 발생하는 것을 막아주겠다는 제네릭 타입 시스템의 목적에 어긋남
    
    ```kotlin
    // 예시
    List<String>[] StringLists = new List<String>[1]; // 1
    List<Integer> intList = List.of(42); // 2
    Object[] objects = stringLists; // 3
    
    objects[0] = intList; // 4
    String s = stringLists[0].get(0); // 5
    ```
    <br>
    
    만약 1이 허용된다고 했을 때, 배열은 공변이니 3이 허용되게 되고 4에서 제네릭은 런타임시 타입이 소거되므로 이 역시 성공하게 됨 ( 런타임 시 List[]가 되어버림 )
    
    이때 5에서 컴파일러는 꺼낸 원소를 자동으로 String으로 형변환 하려 하지만, 이 원소는 Integer이므로 런타임에 ClassException이 발생
    
    ⇒ 이를 방지하려면 제네릭 배열이 생성되지 않도록 컴파일 오류를 발생시켜야 함<br><br>
    
    > 실체화 불가 타입 : `E`, `List<E>`, `List<String>`과 같은 타입
    > 
    
    ⇒ 실체화 되지 않아 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입
    
    ⇒ 소거 매커니즘 때문에 매개변수화 타입 중 실체화 될 수 있는 타입은 List<?>와 Map<?,?>와 같은 비한정적 와일드카드 타입 뿐임 ⇒ 하지만, 거의 안씀<br><br>
    
    **배열에 제네릭을 넣을 수 없기에 불편한 상황도 존재**
    
    예를 들어, 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능
    
    ⇒ 제네릭은 타입 소거 방식으로 동작하므로 특정 타입의 배열을 반환할 방법이 없음
    
    ⇒ 따라서 호출하는 쪽에서 타입을 알려주는 배열을 전달받아 그 배열을 채워서 반환하는 방식을 사용해야 함
    
    ```kotlin
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
        
            // 전달받은 배열 타입 a.getClass()를 기반으로 새 배열 생성
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    
        // 전달받은 배열이 충분히 크면 기존 배열에 복사
        System.arraycopy(elementData, 0, a, 0, size);
    
        if (a.length > size) a[size] = null;
    
        return a;
    }
    
    --- toArray 사용 예시
    
    List<String> list = new ArrayList<>();
    	list.add("사과");
    	list.add("바나나");
    	list.add("체리");
    
    	// toArray 사용 ( 제네릭 타입 유지 )
    	// new String[0]은 런타임에 실제 리스트 크기에 맞춰 동적으로 배열을 생성해줌
    	String[] array = list.toArray(new String[0]);
    ```
    <br>
    
    제네릭 타입과 가변 인수 메서드를 함께 사용하면 경고를 발생
    
    가변 인수 메서드를 호출할 때마다 가변 인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가능 타입이라면 경고가 발생
    
    즉, 배열에 실체화 불가능 타입을 담을 수 없기에 발생하는 에러
    
    ⇒ `@SafeVarargs` 어노테이션으로 대처할 수 있음<br><br>
    
    ```kotlin
    // 생성자에서 컬렉션을 받는 제네릭을 사용하지 않은 버전
    public class Chooser {
    	private final Object[] choiceArray;
    	
    	public Chooser(Collection choices) {
    		choiceArray = choices.toArray();
    	}
    	
    	public Object choose() {
    		Random rnd = ThreadLocalRandom.current();
    		return choiceArray[rnd.nextInt(choiceArray.length)];
    	}
    }
    
    choose 메서드를 호출할 때마다 반환된 Object를 원하는 타입으로 형변환해야 함
    만약, 타입이 다른 원소가 있다면 런타임에 형변환 오류가 발생하게 됨
    ```
    <br>
    
    ```kotlin
    // 제네릭을 사용한 버전
    public class Chooser<T> {
    	private final T[] choiceArray;
    	
    	public Chooser(Collection<T> choices) {
    		choiceArray = choices.toArray();
    	}
    	
    	public Object choose() {
    		...
    	}
    }
    
    Object[]인 choices.toArray()를 T[]인 choiceArray에 대입할 수 없다는 오류 발생
    
    따라서 다음과 같이 변경 (T[]) choices.toArray();
    ⇒ 이 역시 경고 발생
    ⇒ T가 정확히 무슨 타입인지 컴파일 시점에 알 수 없기 때문에, 이 형변환이 런타임에 안전할지 보장할 수 없다는 경고
      ( 런타임에는 자바가 T를 유지하지 않고, 그냥 Object 취급 )
      
    ⇒ 컴파일러가 안전을 보장하지 못할 뿐 안전을 확신한다면 @SafeVarargs을 통해 경고를 숨기자
    ⇒ 애초에 아래와 같이 경고의 원인을 제거하는 것이 낫긴 하지만 .. ..
    ```
    <br>
    

비검사 형변환 경고를 아예 제거하려면 배열 대신 리스트를 사용하면 됨

```kotlin
public class Chooser<T> {
	private final List<T> choiceList;
	
	public Chooser(Collection<T> choices) {
		choiceList = new ArrayList<>(choices);
	}
	
	public Object choose() {
		Random rnd = ThreadLocalRandom.current();
		return choiceList.get(rnd.nextInt(choiceList.size()));
	}
}

⇒ 런타임에 ClassEx.. 을 발생시킬 가능성이 없으니 이렇게 변경할 가치가 있음
```<br>

### 되도록 제네릭 타입으로 만들자

---

JDK가 제공하는 제네릭 타입과 메서드를 사용하는 것은 쉬운편이지만, 제네릭 타입을 새로 만드는 것은 어려움<br><br>

```kotlin
public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;
	
	public stack() {
		eletents = new Object[DEFAULT_INITIAL_CAPACITY];
	}
	
	public void push(Object o) {
		ensureCapacity();
		elements[size++] = o;
	}
	
	public Object pop() {
		if (size == 0) {
			throw new EmptyStackException();
		
		Object result = elements[--size];
		elements[size] = null;
		return result;
	}
	
	public boolean isEmpty() {
		return size == 0;
	}
	
	private void ensureCapacity() {
		if (elements.length == size) {
			elements = Arrays.copyOf(elements, 2 * size + 1);
		}
	}
}
```
<br><br>

일반 클래스를 제네릭 클래스로 만드는 첫 단계는 클래스 선언에 타입 매개 변수를 추가하는 것

```kotlin
public class Stack<E> {
	private E[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;
	
	public stack() {
		eletents = new E[DEFAULT_INITIAL_CAPACITY];
	}
	
	public void push(E e) {
		ensureCapacity();
		elements[size++] = e;
	}
	
	public E pop() {
		if (size == 0) {
			throw new EmptyStackException();
		
		E result = elements[--size];
		elements[size] = null;
		return result;
	}
	...
}
```

⇒ 이 단계에서 대체로 하나 이상의 오류나 경고가 발생

⇒ E와 같은 실체화 불가 타입으로는 배열을 만들 수 없음

⇒ 배열을 사용하는 코드를 제네릭으로 만들려 할 때 항상 이 문제가 발생함<br><br>

[ 해결 방법 ]

1. 제네릭 배열 생성을 금지하는 제약을 우회한는 방법
    
    ⇒ 오류 대신 경고를 내보냄 : 타입 안전하지 않음
    
    ```kotlin
    eletents = (E[]) new E[DEFAULT_INITIAL_CAPACITY];
    ```
    <br>
    
    컴파일러는 이 프로그램이 타입 안전한지 증명할 방법이 없지만, 비검사 형변환이 프로그램의 타입 안전성을 해치지 않음을 스스로 확인해야 함
    
    배열 eletents는 private 필드에 저장되고, 클라이언트로 반환되거나 다른 메서드에 전달되는 일이 없음
    
    또한, push 메서드를 통해 배열에 저장되는 원소의 타입은 항상 E이기 때문에 이 비검사 형변환은 안전함<br><br>
    
    비검사 형변환이 안전함을 직접 증명했다면 범위를 최소로 좁혀 @SuppressWarnings 애너테이션으로 해당 경고를 숨기면 됨
    
    ⇒ 생성자가 비검사 배열을 생성 말고는 하는 일이 없으니 생성자 전체에서 경고를 숨기면 됨
    
    ```kotlin
    @SuppressWarnings("unchecked")
    public stack() {
    	eletents = new E[DEFAULT_INITIAL_CAPACITY];
    }
    ```
    <br>
    
2. elements 필드의 타입을 E[]에서 Object[]로 바꾸는 것
    
    ```kotlin
    E result = elements[--size];
    
    여기서 배열이 반환한 원소를 E로 형변환 할 때 오류 대신 경고가 발생
    ```
    
    E는 실체화 불가 타입이므로 컴파일러는 런타입에 이루어지는 형변환이 안전한지 증명할 방법이 없음
    
    ⇒ 직접 안전한지 증명하고 증명된다면 경고를 숨기면 됨
    
    ```kotlin
    	public E pop() {
    		if (size == 0) {
    			throw new EmptyStackException();
    		
    		@SuppressWarnings("unchecked")
    		E result = elements[--size];
    		
    		elements[size] = null;
    		return result;
    	}
    ```
    <br>
    

이렇듯 제네릭 배열을 생성할 수 없는 제약을 우회하는 두 가지 방법은 많이 쓰이지만, 

첫 번째 방법은 가독성이 더 좋으며, 배열의 타입을 E[]로 선언하여 오직 E 타입 인스턴스만 받음을 명시적으로 보여주고 코드가 더 짧으며, 형 변환을 배열 생성 시 단 한 번만 하면 됨

두 번째 방법은 배열에서 원소를 읽을 때마다 형 변환을 해줘야하기 때문에 첫 번째 방법을 더 주로 사용함<br><br>

하지만, 첫 번째 방법은 런타입 타입이 컴파일 타임 타입과 탈라 힙 오염을 일으키기에 두 번째 방법을 쓰기도 함

( 위의 예시는 힙 오염이 일어나지 않았지만 아래의 예를 보자 )

```kotlin
// 명령줄 인수들을 역순으로 바꿔 대문자로 출력하는 프로그램
// Stack에서 꺼낸 원소에서 String의 toUpperCase 메서드를 호출할 때 명시적 형변환을 수행하지 않으며
// , 컴파일러에 의한 자동 형변환이 항상 성공함을 보장함

public static void main(String[] args) {
	Stack<String> stack = new Stack<>();
	
	for (String arg: args) 
		stack.push(arg);
	
	while(!stack.isEmpty()) 
		sout(stack.pop().toUpperCase());
}
```
<br>

앞의 내용에서 보듯이 배열보다는 리스트 사용을 우선시 하라는 것이 제네릭 배열을 우회해서 사용하는데에 있어 모순되어 보이지만 사실 제네릭 타입 안에서 리스트를 사용하는게 항상 가능하지도, 꼭 더 좋은 것도 아님<br><br>

Stack의 예처럼 대다수의 제네릭 타입은 타입 매개변수에 아무런 제약을 두지 않음

⇒ `Stack<Object>` , `Stack<List<String>>` 등 어떤 참조 타입으로도 Stack을 만들 수 있음<br><br>

단, 기본 타입은 사용할 수 없음

⇒ 제네릭 타입의 근본적인 문제이나, 박싱된 기본 타입을 사용하여 우회할 수 있음<br><br>

타입 매개변수에 제약을 두는 제네릭 타입도 존재 ( DelayQueue )

> `class DelayQueue<E extends Delayed> implements BlockingQueue<E>`
> 

⇒ `Delayed`의 하위 타입만 받는다는 의미

⇒ 이는 형 변환 없이 `Delayed` 클래스의 메서드를 호출할 수 있음 ⇒ ClassCastEx.. 발생 걱정을 할 필요가 x

⇒ 이러한 타입 매개변수 E를 `한정적 타입 매개변수`라고 함<br><br>

**결론**

- 클라이언트에서 직접 형변환을 해야하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하기에 새로운 타입을 설계할 때는 형 변환 없이도 사용할 수 있도록 하자
    
    ⇒ 이를 위해서는 제네릭 타입으로 만들어야 할 경우가 많음<br><br>
    

- 기존 타입 중 제네릭이었어야 하는게 있다면 제네릭 타입으로 변경하자
    
    ⇒ 기존 클라이언트에 영향을 주지 않으며, 새로운 사용자를 편하게 해주는 기능임<br><br>
    

### 되도록이면 제네릭 메서드로 만들자

---

클래스와 마찬가지로 메서드도 제네릭으로 만들 수 있음

매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭이며, Collections의 알고리즘 매커니즘 역시 제네릭<br><br>

```kotlin
// 문제가 있는 메서드
public static Set union(Set s1, Set s2) {
	Set result = new HashSet(s1); // 1
	result.addAll(s2); // 2
	return result;
}

컴파일은 되지만 1번, 2번 부분에서 raw 타입 사용에 대한 경고가 발생

경고를 없애기 위해서는 이 메서드를 타입 안전하게 만들어야 함
⇒ 메서드 선언에서의 세 집합 ( 입력 2개, 반환 1개 )의 원소 타입을 타입 매개변수로 명시하고, 메서드 
  안에서도 이 타입 매개변수만 사용하도록 수정하면 됨
  ( 타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 위치 )
  
// 제네릭 메서드
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
	Set<E> result = new HashSet<>(s1); // 1
	result.addAll(s2); // 2
	return result;
}

단순 제네릭 메서드라면 이정도면 충분하며, 경고 없이 컴파일되고 타입 안전함
```

union 메서드는 집합 3개의 타입이 모두 같아야하며, 이를 한정적 와일드카드 타입을 사용하여 더 유연하게 개선할 수 있음<br><br>

때때로 불변 객체를 여러 타입으로 활용할 수 있게 만들어야 할 때가 있음

제네릭은 런타임에 타입 정보가 소거되므로, 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있지만, 이렇게 하기 위해선 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 함

⇒ 제네릭은 컴파일 타임에만 작동하기 때문에 런타임에 타입을 바꾸는 건 불가능하므로 정적 팩터리 메서드로 타입 캐스팅된 인스턴스를 반환해야 함

⇒ 싱글턴 팩터리

```kotlin
// 싱글턴 객체
private static final UnaryOperator<Object> IDENTITY_FN = (x) -> x;

// 정적 제네릭 팩터리 메서드
@SuppressWarnings("unchecked")
public static <T> UnaryOperator<T> identityFunction() {
    return (UnaryOperator<T>) IDENTITY_FN;
}

// 사용 예시 
UnaryOperator<String> sameString = identityFunction();
System.out.println(sameString.apply("hello")); // "hello"

UnaryOperator<Integer> sameInteger = identityFunction();
System.out.println(sameInteger.apply(42)); // 42
```
<br>

항등함수를 담은 클래스를 만든다고 했을 때 ( 원래는 Function.identity를 사용하면 됨 )

항등함수 객체는 상태가 없으니 요청할 때마다 새로 생성하는 것은 낭비이며, 자바의 제네릭이 실체화되면 항등함수를 타입별로 만들어야하지만, 소거 방식을 통한 제네릭 싱글턴을 이용하면 됨

```kotlin
// 위 코드와 같음
IDENTITY_FN를 UnaryOperator<T>로 형변환하면 비검사 형변환 경고가 발생
T가 어떤 타입이든 UnaryOperator<Object>는 UnaryOperator<T>가 아니기 때문

하지만, 항등함수는 입력 값을 수정 없이 그대로 반환하는 특별한 함수이므로, T가 어떤 타입이든 
UnaryOperator<T>를 사용하도 타입 안전함

따라서, 경고를 숨겨도 되므로 코드처럼 @SuppressWarnings("unchecked")를 사용
```
<br>

**재귀적 타입 한정**

`자기 자신이 들어간 표현식을 사용하여 타입 매새변수의 허용 범위를 한정하는 것`

```kotlin
class MyClass<T extends MyClass<T>> {
    ...
}

여기서 T는 반드시 MyClass<T>의 하위 타입이어야함
```
<br>

주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰임

```kotlin
public interface Comparable<T> {
	int compareTo(T o);
}
```

여기서 타입 매개변수 T는 Comparable<T>를 구현한 타입이 비교할 수 있는 원소의 타입을 정의하며 실제로 거의 모든 타입은 자신과 같은 타입의 원소와면 비교할 수 있음

따라서, Comparable<String>을 구현하고 Integer는 Comparable<Integer>를 구현하는 식

```kotlin
public static <E extends Comparable<E>> E max(Collection<E> c);

<E extends Comparable<E>>는 "모든 타입 E는 자신과 비교할 수 있다"라는 의미
```
<br>

```kotlin
컬렉션에 담긴 원소의 자연적 순서를 기준으로 최댓값을 계산하며, 컴파일 오류나 경고는 발생하지 않는 구현
public static <E extends Comparable<E>> E max(Collection<E> c) {
	if(c.isEmpty())
		throw ..
	
	E result = null;
	for (E e: c) 
		if (result == null || e.compareTo(result) > 0)
			result = Objects.requiredNotNull(e);
	
	return result;
}
```
<br>

### 한정적 와일드카드를 사용하여 API 유연성을 높여라

---

**매개변수화 타입은 불공변**

즉, 서로 다른 타입 Type1과 Type2가 있을 때 List<Type1>은 List<Type2>의 하위 타입도, 상위 타입도 아님

예를 들어 List<String>은 List<Object>의 하위 타입이 아니라는 의미<br><br>

하지만, 어떻게 보면 위의 말이 맞는 말임

리스코프 치환 원칙은 서브 타입은 이것의 기반 타입을 대체할 수 있어야 한다는 원칙인데, List<Object>에는 어떤 타입의 객체도 넣을 수 있지만 List<String>은 String 객체만 넣을 수 있기에 이 원칙을 위배함

따라서, List<String>은 List<Object>의 하위 타입이 아니라는 말이 맞는 말임<br><br>

하지만, 때로는 불공변 방식보다 유연한 무언가가 필요

```kotlin
// Stack 클래스에서 일련의 원소를 스택에 넣는 메서드를 추가해야한다고 하면
public void pushAll(Iterable<E> src) {
	for(E e: src) 
		push(e);
}
```

위 메서드는 잘 컴파일되지만 완벽하지는 않음

Iterable src의 원소 타입이 스택의 원소 타입과 일치하면 잘 작동하지만, Stack<Number>로 선언한 후 pushAll(intVal)을 호출해보면 ( intVal은 Integer 타입 ) Integer은 Number의 하위 타입이지만 실제로는 오류가 발생

따라서, Stack<Number>에서 pushAll(Iteratable<Integer>)를 호출하면 컴파일 에러 발생

⇒ 매개변수화 타입이 불공변이기 때문 !!<br><br>

위 문제의 해결책은 `한정적 와일드 카드`를 사용하는 것

pushAll의 입력 매개변수 타입은 `E 타입의 Iterable`가 아니라 `E거나 E의 하위 타입인 Iterable`이어야 함

즉, E 타입이거나 E의 하위 타입인 Iterable를 입력 매개변수로 넣도록 해야함

⇒ `Iterable<? extends E>` 으로 선언하면 됨 ( E 자신과 E의 모든 하위 타입을 허용 )

⇒ `pushAll(Iteratable<Integer>)` 를 호출했을 때 컴파일 에러가 발생하지 않음<br><br>

정리해보자면

제네릭은 기본적으로 불공변이기 때문에 `Iterable<E> src`로 선언하면 E의 하위 타입을 가진 Iterable은 대입할 수 없어 컴파일 오류가 발생

하지만, `Iterable<? extends E>`로 선언하면, 컴파일러에게 E 또는 그 하위 타입의 원소를 가진 Iterable도 허용한다는 뜻을 명시하게 되므로 컴파일 오류는 발생하지 않음<br><br>

이제 popAll 메서드를 수정해보자면 ( ⭐️ Stack 안의 모든 원소를 주어진 컬렉션에 옮겨 담는 역할 )

```kotlin
public void popAll(Collection<E> dst) {
	while (!isEmpty())
		dst.add(pop())
}
```

컬렉션의 원소 타입이 스택의 원소 타입과 일치한다면 말끔히 컴파일되고 문제 없이 동작하지만

, 만약 Stack<Number>의 원소를 Object 컬렉션에 옮기려고 한다면 문제가 발생함

⇒ 제네릭의 불공변성 때문<br><br>

위와 같은 상황 역시 와일드카드 타입으로 해결할 수 있음

⇒ E 타입이거나 E의 상위 타입을 원소로 받는 Collection을 매개변수로 허용한다는 의미

```kotlin
public void popAll(Collection<? super E> dst) {
	while (!isEmpty())
		dst.add(pop())
}
```
<br>

**PECS ( Producer Extends Consumer Super )**

생산자

`<? extends E>`

`메서드 안에서 값을 꺼내는 역할을 하는 매개변수`

`꺼내온 값을 다른 곳에 쓰기 위해 읽는 것이 핵심`

ex ) pushAll(Iterable<? extends E> src)에서의 src ( src는 요소를 꺼내기만 함 → 읽기만 함 )<br><br>

소비자 

`<? super E>`

`메서드 안에서 값을 집어넣는 역할을 하는 매개변수`

`add() 등을 통해 값을 쓰는 것이 핵심` 

ex ) popAll(Collection<? super E> dst)에서의 dst ( 값을 받기만 함 → 쓰기만 함 )<br><br>

유연성을 극대화 하려면 입력 매개변수에 와일드카드 타입을 사용하자

매개변수가 읽기 전용이면 extends, 쓰기 전용이면 super를 사용하지만, 읽기와 쓰기 모두 한다면 와일드카드 타입을 써도 좋을게 없으므로, 차라리 E 고정 타입을 사용하자<br><br>

어떤 와일드카드를 써야 하는지 모르겠다면 PECS ( Producer Extends Consumer Super )를 기억하자

⇒ ⭐️ 매개변수화 타입 T가 생산자라면 ( 읽기만 한다면 ) extends, 소비자라면 ( 쓰기만 한다면 ) super를 사용<br><br>

앞선 예시 코드에서

```kotlin
public Chooser(Collection<T> choices)에서 choices는 값을 읽기만 하므로 ( 생산자 )

Collection<? extends T>로 변경
```

```kotlin
publi static <E> Set<E> union(Set<E> s1, Set<E> s2)에서 s1, s2는 값을 읽기만 하므로

하므로 union(Set<? extends E> s1, Set<? extends E> s2)로 변경
```

⇒ 매개변수에 E의 하위 타입 역시 전달할 수 있게 됨<br><br>

다음 에시를 보면

```kotlin
public static <E extends Comparable<E>> E max(List<E> list)

⇒ 타입 매개변수 E는 반드시 Comparable를 구현한 타입이어야 한다는 의미 ⭐️⭐️

위 코드를 아래와 같이 변경할 수 있음 ↓↓↓

public static <E extends Comparable<? super E>> E max(List<? extends E> list)

E는 Comparable을 구현해야 하는데, 그 Comparable은 E 자신뿐만 아니라 E의 상위 타입을 비교 대상으로 
하는 Comparable도 허용한다는 의미 ⭐️⭐️
즉, E가 자기 자신 또는 상위 타입과 비교 가능해야 한다는 의미
```

Comparable은 언제나 소비자이므로 Comparable<E> 보다는 Comparable<? super E>가 나음<br><br>

**타입 매개변수와 와일드카드에는 공통되는 부분이 있어, 메서드를 정의할 때 어느 것을 사용해도 괜찮다**

```kotlin
// 주어진 리스트에서 명시한 두 인덱스의 아이템들을 교환하는 정적 메서드를 두 방식 모두로 정의해보는 예시

public static <E> void swap(List<E> list, int i, int j);

public static void swap(List<?> list, int i, int j);
```
<br>

둘 중 어느 것이 나을까 ?

public API라면 두 번째가 나음

⇒ 어떤 리스트던 이 메서드에 넘기면 명시한 인덱스의 원소들을 교환해주기 때문이며, 매개변수 타입을 신경쓰지 않아도 되기 때문<br><br>

기본 규칙

- 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하자
    
    ( 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸자 )
    
    ```kotlin
    public static <T> void printList(List<T> list) {
        ...
    }
    
    ⇒ T가 매개변수 타입에서 한 번만 나오고 반환 타입에도 없으니 굳이 <T>를 선언할 필요 없이 아래로 변경
    
    public static void printList(List<?> list) {
        ...
    } 
    ```
    
    ⇒ <T>를 선언하면 메서드 시그니처가 복잡해지기에, 그냥 한 번만 쓴다면 와일드카드로 대체하는게 간단함<br><br>
    
    하지만, 이 방식에는 문제가 하나 있음
    
    ```kotlin
    public static void swap(List<?> list, int i, int j) {
    	list.set(i, list.set(j, list.get(i)));
    }
    ```
    
    ⇒ 이 코드 컴파일 시 오류 메세지가 생김 ( 방금 꺼낸 원소를 리스트에 다시 넣을 수 없음 )
    
    ⇒ 리스트의 타입이 List<?>이기에 null 외에는 넣을 수 없다는 원칙 때문 .. ..<br><br>
    
    이를 해결하기 위해서는 와일드카드 타입의 실제 타입을 알려주는 메서드를 private 도우미 메서드로 따로 작성하여 활용하는 방식을 사용해야 함
    
    ( 실제 타입을 알아내려면 이 도우미 메서드는 제네릭 메서드이어야 함 )
    
    ```kotlin
    public static void swap(List<?> list, int i, int j) {
    	swapHelper(list, i, j);
    }
    
    private static <E> void swapHelper(List<E> list, int i, int j) {
    	list.set(i, list.set(j, list.get(i)));
    }
    ```
    
    ⇒ swapHelper 메서드는 리스트가 List<E>임을 알고 있으니 오류가 발생하지 않음
    
    ⇒ swap 메서드를 호출하는 클라이언트는 복잡한 swapHelper의 존재를 모른채 혜택을 누릴 수 있음 <br><br>
    

**결론**

- 조금 복잡하더라도 와일드카드 타입을 사용하면 API가 훨씬 유연해짐 ( PECS 방식을 기억하자 )
- Comparable과 Comparator 모두 소비자이다.<br><br>

### 제네릭과 가변인수

---

가변인수 메서드와 제네릭을 같이 사용할 때의 구현 방식에는 허점이 존재<br><br>

가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어지는데, 내부로 감춰야했을 이 배열을 클라이언트에 노출하는 문제가 발생하고 이 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생함

실체화 불가 타입은 런타임에는 컴파일 타임보다 타입 관련 정보를 적게 담고 있고, 제네릭은 실체화 되지 않는데 , 메서드를 선언할 때 실체화 불가 타입으로 varagrs 매개변수를 선언하면 컴파일러가 경고를 보냄

⇒ 제네릭 varargs는 런타임에 타입 정보가 사라져서, 컴파일러가 타입 안전성을 완전히 보장할 수 없기 때문<br><br>

매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생

⇒ 다른 타입의 객체를 참조하는 상황에서는 컴파일러가 자동 생성한 형변환이 실패할 수 있기 때문

```kotlin
static void danerous(List<String>... stringLists) {
	List<Integer> intList = List.of(42);
	
	// varargs 매개변수 stringLists는 내부적으로 List<String>[] 배열
	// 하지만 제네릭 소거 때문에 런타임에는 그냥 List[] → Object[] 로도 참조 가능
	Object[] objects = stringLists;
	
	objects[0] = intList;
	
	// stringLists는 컴파일 때 String으로 알고 있으므로, 이를 꺼낼 때 String으로 자동 형변환 진행
	String s = stringLists[0].get(0); // 런타임에 ClassCastException
}
```

⇒ 이처럼 타입 안전성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않음<br><br>

**제네릭 배열을 프로그래머가 직접 생성하는 것은 허용하지 않으면서, 제네릭 varargs 매개변수를 받는 메서드를 선언할 수 있게 하는 이유 ( 나중에 오류를 내면서까지 그냥 경고로 끝내는 이유 )**

`제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 메서드가 실무에서 유용하기 때문 (그래서 위 상황을 수용)`<br><br>

사실 자바 라이브러리에서도 이런 메서드를 여러 개 제공

⇒ `Arrays.asList(T… a)` , `Collections.addAll(Collection<? super T> c, T… elements)` …

⇒ 이 예시들은 앞선 문제가 있는 메서드에 비해 안전함<br><br>

**`@SafeVarargs` 어노테이션를 사용하여 메서드가 타입 안전함을 보장하도록 할 수 있고 이를 통해 경고를 제거할 수 있지만, 확실하지 않다면 절대 이 어노테이션을 사용해서는 안됨**

( `@SafeVarargs`는 정적 혹은 final 인스턴스 메서드에만 붙일 수 있음 )

**그러면 어떻게 메서드가 안전한지 확신할 수 있을까** 

가변인수 메서드를 호출할 때 vargars 매개변수를 담는 제네릭 배열이 만들어지는데 이 배열에 아무것도 저장되지 않고, 이 배열의 참조가 밖으로 노출되지 않는다면 타입 안전함

즉, varargs 배열을 수정하거나 외부에 노출시키지 않고, 단순히 인수 전달, 읽기 용도로만 쓰면 안전<br><br>

이때, varargs 매개변수 배열에 아무것도 저장하지 않고도 타입 안전성을 깰 수 있으니 주의해야 함

```kotlin
static <T> T[] toArray(T... args) {
	return args;
}

이 메서드가 반환하는 배열의 타입은 이 메서드에 인수를 넘기는 컴파일 타임에 결정되는데, 그 시점에 
컴파일러가 충분한 타입 정보를 얻지 못하면, 잘못된 타입을 추론해서 런타임 오류가 날 수 있음

static <T> T[] pickTwo(T a, T b, T c) {
	switch(ThreadLocalRandom.current().nextInt(3)) {
		case 0: return toArray(a, b);
		case 1: return toArray(a, c);
		case 2: return toArray(b, c);
	}
	throw new AssertionError();
}

컴파일러는 toArray에 넘길 T 인스턴스 2개를 담을 varargs 매개변수 배열을 만드는 코드를 생성하는데
이는 Object[] ⇒ pickTwo에 어떤 타입의 객체를 넘기더라도 담을 수 있는 구체적인 타입이기 때문

그리고, toArray 메서드가 돌려준 이 배열이 그대로 pickTwo를 호출한 클라이언트에 전달됨
즉, pickTwo는 항상 Object[] 타입을 반환하는 셈

만약 String[] attributes = pickTwo("asd", "qwe", "zxc");를 호출한다면 clasCastEx.. 던짐
⇒ String[]로 형변환하는 코드를 컴파일러가 자동 생성하기에 Object는 String[]의 하위 타입이 아니기 때문

이러한 예는 제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다는 것을 보여줌
단, 예외가 두 가지 존재
1. @SafeVarargs로 제대로 어노테이트 된 또 다른 varargs 메서드에 넘기는 것
2. 이 배열 내용의 일부 함수를 호출만 하는 ( varargs를 받지 않는 ) 일반 메서드에 넘기는 것

예제 1
@SafeVarargs
static <T> List<T> flatten(List<? extends T>... lists) {
	List<T> result = new ArrayLisy<>();
	for (List<? extends T> list: lists) 
		result.addAll(list);
	
	return result;
}

@SafeVarargs를 사용할 때는 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 
@SafeVarargs를 사용하자
그래야 사용자를 헷갈리게 하는 컴파일러 경고를 없앨 수 있음 
⇒ 안전하지 않은 varargs 메서드는 절대 작성해서는 안된다는 의미이기도 함

제네릭 varargs 매개변수를 사용하며, 힙 경고가 뜨는 메서드가 있다면 안전한지 점검
1. varargs 매개변수 배열에 아무것도 저장하지 않는지
2. 그 배열을 신뢰할 수 없는 코드에 노출하였는지

@SafeVarargs이 유일한 정답은 아님
varagrs 매개변수를 List 매개변수로 바꿀 수도 있음

static <T> List<T> flatten(List<List<? extends T>> lists) {
	List<T> result = new ArrayLisy<>();
	for (List<? extends T> list: lists) 
		result.addAll(list);
	
	return result;
}

정적 팩터리 메서드인 List.of를 활용하면 다음과 같이 이 메서드에 임의 개수의 인수를 넘길 수 있음
( List.of 메서드에 @SafeVarargs 어노테이션이 있기 때문에 가능한 것 )

이 방식의 장점은 컴파일러가 이 메서드의 타입 안전성을 검증할 스 있다는 것
@SafeVarargs을 직접 달지 않아도 되고, 실수로 안전하다고 판단할 걱정도 없음

static <T> List<T> pickTwo(T a, T b, T c) {
	switch(ThreadLocalRandom.current().nextInt(3)) {
		case 0: return List.of(a, b);
		case 1: return List.of(a, c);
		case 2: return List.of(b, c);
	}
	throw new AssertionError();
}

List<String> attributes = pickTwo("asd", "qwe", "zxc")와 같이 사용하며 배열 없이 제네릭만 
사용하므로 타입 안전함
```
<br>

**결론**

가변인수와 제네릭은 조합이 좋지 않음

제네릭 varargs 매개변수는 타입 안전하지 않지만 허용되는데, 메서드에 제네릭 ( 또는 매개변수화된 ) varagrs 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음 @SafeVarargs를 사용하여 사용하는데 불편함이 없도록 하자
