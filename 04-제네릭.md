### raw 타입은 사용하지 말자

---

> 제네릭 클래스 :  타입 매개변수가 쓰인 클래스
> 

> 제네릭 인터페이스 : 타입 매개변수가 쓰인 인페이스
> 

`이 둘을 통틀어 제네릭 타입이라 칭함`

Ex ) List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받음<br><br>

**각각의 제네릭 타입은 일련의 매개변수화 타입을 정의**

⇒ 먼저 클래스 이름이 나오고, 이어서 꺾쇠 괄호 안에 실제 타입 매개변수를 나열

Ex ) List<String>은 원소의 타입이 String인 리스트를 의미하는 매개변수화 타입<br><br>

**제네릭 타입을 하나 정의하면 이에 딸린 raw 타입도 함께 정의됨**

> raw 타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때
> 

Ex ) List<String>의 raw 타입 : List<br><br>

raw 타입은 타입 선언에서 제네릭 정보를 사용하지 않아 모든 제네릭 타입 정보가 제거된 것처럼 동작하며, 이는 제네릭 도입 이전의 코드와의 호환성을 유지하기 위해 제공된 기능임

```kotlin
// 예시: Stamp 인스턴스만 취급
private final Collection stamps = ...;

이 코드는 실수로 Stamp 대신 다른 것을 넣어도 아무 오류 없이 컴파일되고 실행됨
이후 런타임에서 Stamp 타입으로 형 변환을 할 때 오류가 발생하게 됨
```

⇒ raw 타입은 타입 안정성을 보장하지 못하고, 언어적 차원에서 막지는 않지만 절대로 사용해서는 안됨

⇒ raw 타입을 사용하게 되면 제네릭이 주는 안전성과 표현력을 잃게 됨<br><br>

위의 코드를 아래와 같이 수정하면 컴파일러가 stamps에 Stamp의 인스턴스만 넣어야 함을 인지하므로 만약, Stamp 인스턴스 대신 다른 것을 넣는다면 컴파일 에러가 발생하게 됨

```kotlin
private final Collection<Stamp> stamps = ...;
```
<br>

**TMI ) 그럼 왜 raw 타입을 만들어 놓은걸까** 

자바가 제네릭을 사용하기 전 제네릭 없이 작성한 수많은 코드와 제네릭을 사용한  새로운 코드에 호환성을 위함

List와 같은 raw 타입은 사용해서는 안되지만 List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 OK<br><br>

**List와 매개변수화 타입은 List<Object>의 차이는 무엇일까 ?**

⇒ List는 제네릭 타입을 완전히 제거한 것이고 List<Object>는 모든 타입을 허용한다는 의미를 컴파일러에게 명확히 전달한 것이기 때문<br><br>

**List<String>은 List raw 타입에는 넘길 수 있지만 List<Object>에는 넘길 수 없음**

⇒ 제네릭 하위 타입 규칙 때문

즉, List<String>은 List raw 타입의 하위 타입이지만, List<Object>의 하위 타입은 아님<br><br>

**제네릭은 기본적으로 불공변적으로 설계**

> 불공변성 :  A가 B의 하위 타입이더라도, List<A>는 List<B>의 하위 타입이 아님
> 

> 공변성 : A가 B의 하위 타입이면, List<A>도 List<B>의 하위 타입 ⇒ 배열이 이에 해당
> 

```kotlin
String str = "hello";
Object obj = str;  // 가능 ( String은 Object의 하위 타입이기 때문 )

List<String> strings = new ArrayList<>();
List<Object> objects = strings; // 컴파일 오류

만약의 위의 오류 코드가 허용된다면 ??
objects.add(123); // Integer 추가 가능
String s = strings.get(0); // Integer → 런타임 오류
```

⇒ 타입 안전성을 보장하기 위해 제네릭은 기본적으로 불공변적으로 설계<br><br>

**예시**

```kotlin
public static void main (...) {
	List<String> strings = new ArrayList<>();
	
	unsafeAdd(strings, Integer.valueOf(42));
	String s = strings.get(0);
}

private static void unsafeAdd(List list, Object o) {
	list.add(o)
}
```
<br>

위 코드는 컴파일은 되지만 raw 타입인 List를 사용하여 경고가 발생 

이후, 실행을 하게 되면 strings.get(0)의 결과를 형변환하려 할 때 예외가 발생<br><br>

그럼 만약 List를 매개변수화 타입인 List<Object>로 바꾼다면 ?

컴파일 에러 발생 : `List<String> cannot be converted to List<Object>`

⇒ unsafeAdd의 List 타입에 List<String>을 넣을 수 없기 때문<br><br>

**그러면 원소의 타입을 몰라도 되는 raw 타입을 사용해도 될까 라고 생각할 수도 있음**

```kotlin
// 잘못된 예
static int newElementInCommon(Set s1, Set s2) {
	int result = 0;
	
	for (Object o: s1) 
		if (s2.contains(o1))
			result++;
	
	return result;
}
```

⇒ 이 코드는 동작은 하지만 raw 타입을 사용했기에 안전하지 않음<br><br>

**raw 타입 대신 비한정적 와일드카드 타입을 사용하자 ⭐️**

`제네릭 타입을 사용하고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 때 사용`<br><br>

비한정적 와일드카드 타입을 사용하여 newElementInCommon을 다시 선언

```kotlin
static int newElementInCommon(Set<?> s1, Set<?> s2) {...}
```
<br>

와일드카드 타입은 안전하지만 raw 타입은 안전하지 않음

raw 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽지만

, Collection<?>에는 null 외의 어떤 원소도 넣을 수 없음 → 다른 원소를 넣으려 하면 컴파일 오류 발생<br><br>

⭐️⭐️⭐️

따라서, <?>로 선언한 이유는 메서드 내에서 컬렉션을 읽기 전용으로 만들어 원본 컬렉션을 건드리지 않음을 보장
⇒ 삽입-수정은 불가 , 삭제는 가능<br><br>

위와 같은 제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드 카드 타입을 사용<br><br>

**raw 타입을 쓰지말라는 규칙의 예외**

1. class 리터럴에는 raw 타입을 써야 한다
    
    자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 함
    
    Ex ) List.class, String[] class, int.class는 허용하고 List<String>.class, List<?>.class는 허용 안함<br><br>
    

2. instanceOf 연산자
    
    런타입에는 제네릭 타입 정보가 지워지므로 instanceOf 연산자는 비한정적 와일드카드 타입 외의 매개변수화 타입에는 적용할 수 없으며, raw 타입이든 비한정적 와일드카드 타입이든 instanceOf는 똑같이 동작
    
    ⇒ 비한정적 와일드카드 타입의 꺽쇠 괄호와 물음표는 지저분하므로 차라리 raw 타입을 사용
    
    ```kotlin
    // raw 타입을 사용해도 되는 좋은 예 - instanceOf 연산자
    if (o instanceOf Set) {
    	Set<?> s = (Set<?>) o;
    }
    
    o의 타입이 Set임을 확인한 후 와일드카드 타입인 Set<?>로 형변환 해야함
    ⇒ 이는 검사 형변환이므로 컴파일러 경고가 발생하지 않음
    ```
    <br>
    

**결론**

- raw 타입을 사용하면 런타임 예외가 발생할 수 있으니 사용하면 안됨
    
    ( 제네릭 도입 전 이전 코드와의 호환성을 위해 제공된 것 뿐)
    
- Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드 카드 타입이고, 이들의 raw 타입인 Set은 제네릿 타입에 속하지 않음
- Set<Object>와 Set<?>는 안전하지만, raw 타입인 Set은 안전하지 않음<br><br>

### 비검사 경고를 제거하자

---

제네릭을 사용하게 되면 비검사 형 변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변 인수 타입 경고, 비검사 변환 경고 등의 수많은 컴파일러 경고를 보게 되는데, 이러한 비검사 경고를 쉽게 제거할 수 있음<br><br>

**비검사 형 변환 경고**

```kotlin
Set<Lark> exltation = new HashSet();

HashSet의 타입 매개변수가 지정되지 않아 컴파일러가 타입 안전성을 보장할 수 없다는 경고 발생

new HashSet은 Raw Type이므로 컴파일러는 내부적으로 HashSet을 HashSet<Object>로 취급
하지만, 이를 Set<Lark>로 대입하려고 하니 컴파일러는 Object → Lark 변환이 안전한지 확인할 수 없으므로
비검사 형 변환 경고를 발생
```
<br>

위의 코드를 아래와 같이 다이아몬드 연산자를 통해 컴파일러가 올바른 실제 타입 매개변수를 추론하도록 해야함

```kotlin
Set<Lark> exltation = new HashSet<>();
```
<br>

경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 `@SuppressWarnings(”unchecked”)`를 사용

`@SuppressWarnings` 어노테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 사용할 수 있지만, 항상 가능한 좁은 범위에 적용하자 !

보통은 변수 선언, 아주 짧은 메서드, 혹은 생성자가 될 것인데, 이를 사용하면 심각한 경고를 무시할 수 있으니 절대로 클래스 전체에 적용해서는 안됨

한 줄이 넘는 메서드나 생성자에 달린 `@SuppressWarnings` 어노테이션을 발견하면 지역변수 선언으로 옮기자

⇒ 이를 위해 새로운 지역변수를 선언해야하겠지만 그래도 하는게 좋음

```kotlin
// 경고를 발생시키는 toArray 메서드의 예

private Object[] elements; // 내부 배열
private int size;
    
public <T> T[] toArray(T[] a) {
	if (a.length < size) 
		return (T[]) Arrays.copyOf(elements, size, a.getClass());
	
	System.arrayCopy(elements, 0, a, 0, size);
	if (a.length > size) 
		a[size] = null;
	return a;
}

Arrays.copyOf의 첫 번째 인자는 T[]를 받지만 Object[]를 넘기에 컴파일 시 경고 발생
```
<br>

`@SuppressWarnings` 어노테이션은 선언에만 사용할 수 있기에 return 문에서는 `@SuppressWarnings` 을 사용하는 것은 불가능하며, 메세드 전체에 사용한다면 범위가 넓어지므로 반환값을 담을 지역변수를 선언하고 이 변수에 사용하는 것이 좋음

```kotlin
// 올바른 toArray 메서드의 예
public <T> T[] toArray(T[] a) {
	if (a.length < size) 
		@SuppressWarnings(”unchecked”) T[] result =  
			(T[]) Arrays.copyOf(elements, size, a.getClass());
		
		return result
	
	System.arrayCopy(elements, 0, a, 0, size);
	if (a.length > size) 
		a[size] = null;
		
	return a;
}

깔끔히 컴파일되며, 비검사 경고를 숨기는 범위도 최소가 됨
```
<br>

`@SuppressWarnings(”unchecked”)` 어노테이션을 사용한다면 경고를 무시해도 안전한 이유를 항상 주석으로 남겨놔야 함<br><br>

### 배열 보단 리스트를 사용하자

---

`배열과 리스트에는 큰 차이가 존재`<br><br>

1. 배열은 공변하다.
    - 배열은 공변하다 ( 공변 : 함께 변하다 )
    - 리스트는 비공변하다. ( 비공변 : 함께 변하지 않는다 )<br><br>
    
    > 공변성 : sub가 super의 하위 타입이라면 sub[]는 super[]의 하위 타입이 된다
    > 
    
    > 비공변성 : List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다
    >

    <br><br>
    
    이렇게 보면 배열 쪽이 더 좋다고 생각할 수도 있지만, 문제가 되는 쪽은 배열임
    
    ```kotlin
    // 런타임에 실패
    Object[] objectArray = new Long[1];
    objectArray[0] = "타입이 달라 넣을 수 없음" // ArrayStoredException
    
    // 컴파일조차 되지 않음
    List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입
    ```
    <br>
    
    오류가 발생하는 시기가 배열은 런타임 때 알게 되지만 리스트를 사용하면 바로 알 수 있음<br><br>
    

2. 배열은 실체화가 됨
    
    배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인하는데, 따라서 Long 배열에 String을 넣으려하면 ArrayStoredException 예외가 발생
    
    하지만, 제네릭은 타입 정보가 런타임에는 소거되므로 원소 타입을 컴파일 타입에만 검사하며 런타임에는 알수조차 없음
    
    ⇒ 컴파일 후에는 원래 타입 정보가 제거되어 Raw Type으로 변환되고, 타입 검사는 컴파일러가 생성한 캐스트 코드에서만 수행됨<br><br>
    
    이러한 차이 때문에 배열과 제네릭은 잘 어우러지지 못함
    
    ⇒ 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없음
    
    Ex ) `new List<E>[]`, `new List<String>[]`, `new E[]` 식으로 작성하면 컴파일 오류 발생<br><br>
    
    **제네릭 배열을 만들지 못하는 이유는 무엇일까 ?**
    
    `타입 안전하지 않기 때문`<br><br>
    
    이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCast..가 발생할 수 있음
    
    런타임에 ClassCast…이 발생하는 것을 막아주겠다는 제네릭 타입 시스템의 목적에 어긋남
    
    ```kotlin
    // 예시
    List<String>[] StringLists = new List<String>[1]; // 1
    List<Integer> intList = List.of(42); // 2
    Object[] objects = stringLists; // 3
    
    objects[0] = intList; // 4
    String s = stringLists[0].get(0); // 5
    ```
    <br>
    
    만약 1이 허용된다고 했을 때, 배열은 공변이니 3이 허용되게 되고 4에서 제네릭은 런타임시 타입이 소거되므로 이 역시 성공하게 됨 ( 런타임 시 List[]가 되어버림 )
    
    이때 5에서 컴파일러는 꺼낸 원소를 자동으로 String으로 형변환 하려 하지만, 이 원소는 Integer이므로 런타임에 ClassException이 발생
    
    ⇒ 이를 방지하려면 제네릭 배열이 생성되지 않도록 컴파일 오류를 발생시켜야 함<br><br>
    
    > 실체화 불가 타입 : `E`, `List<E>`, `List<String>`과 같은 타입
    > 
    
    ⇒ 실체화 되지 않아 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입
    
    ⇒ 소거 매커니즘 때문에 매개변수화 타입 중 실체화 될 수 있는 타입은 List<?>와 Map<?,?>와 같은 비한정적 와일드카드 타입 뿐임 ⇒ 하지만, 거의 안씀<br><br>
    
    **배열에 제네릭을 넣을 수 없기에 불편한 상황도 존재**
    
    예를 들어, 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능
    
    ⇒ 제네릭은 타입 소거 방식으로 동작하므로 특정 타입의 배열을 반환할 방법이 없음
    
    ⇒ 따라서 호출하는 쪽에서 타입을 알려주는 배열을 전달받아 그 배열을 채워서 반환하는 방식을 사용해야 함
    
    ```kotlin
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
        
            // 전달받은 배열 타입 a.getClass()를 기반으로 새 배열 생성
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    
        // 전달받은 배열이 충분히 크면 기존 배열에 복사
        System.arraycopy(elementData, 0, a, 0, size);
    
        if (a.length > size) a[size] = null;
    
        return a;
    }
    
    --- toArray 사용 예시
    
    List<String> list = new ArrayList<>();
    	list.add("사과");
    	list.add("바나나");
    	list.add("체리");
    
    	// toArray 사용 ( 제네릭 타입 유지 )
    	// new String[0]은 런타임에 실제 리스트 크기에 맞춰 동적으로 배열을 생성해줌
    	String[] array = list.toArray(new String[0]);
    ```
    <br>
    
    제네릭 타입과 가변 인수 메서드를 함께 사용하면 경고를 발생
    
    가변 인수 메서드를 호출할 때마다 가변 인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가능 타입이라면 경고가 발생
    
    즉, 배열에 실체화 불가능 타입을 담을 수 없기에 발생하는 에러
    
    ⇒ `@SafeVarargs` 어노테이션으로 대처할 수 있음<br><br>
    
    ```kotlin
    // 생성자에서 컬렉션을 받는 제네릭을 사용하지 않은 버전
    public class Chooser {
    	private final Object[] choiceArray;
    	
    	public Chooser(Collection choices) {
    		choiceArray = choices.toArray();
    	}
    	
    	public Object choose() {
    		Random rnd = ThreadLocalRandom.current();
    		return choiceArray[rnd.nextInt(choiceArray.length)];
    	}
    }
    
    choose 메서드를 호출할 때마다 반환된 Object를 원하는 타입으로 형변환해야 함
    만약, 타입이 다른 원소가 있다면 런타임에 형변환 오류가 발생하게 됨
    ```
    <br>
    
    ```kotlin
    // 제네릭을 사용한 버전
    public class Chooser<T> {
    	private final T[] choiceArray;
    	
    	public Chooser(Collection<T> choices) {
    		choiceArray = choices.toArray();
    	}
    	
    	public Object choose() {
    		...
    	}
    }
    
    Object[]인 choices.toArray()를 T[]인 choiceArray에 대입할 수 없다는 오류 발생
    
    따라서 다음과 같이 변경 (T[]) choices.toArray();
    ⇒ 이 역시 경고 발생
    ⇒ T가 정확히 무슨 타입인지 컴파일 시점에 알 수 없기 때문에, 이 형변환이 런타임에 안전할지 보장할 수 없다는 경고
      ( 런타임에는 자바가 T를 유지하지 않고, 그냥 Object 취급 )
      
    ⇒ 컴파일러가 안전을 보장하지 못할 뿐 안전을 확신한다면 @SafeVarargs을 통해 경고를 숨기자
    ⇒ 애초에 아래와 같이 경고의 원인을 제거하는 것이 낫긴 하지만 .. ..
    ```
    <br>
    

비검사 형변환 경고를 아예 제거하려면 배열 대신 리스트를 사용하면 됨

```kotlin
public class Chooser<T> {
	private final List<T> choiceList;
	
	public Chooser(Collection<T> choices) {
		choiceList = new ArrayList<>(choices);
	}
	
	public Object choose() {
		Random rnd = ThreadLocalRandom.current();
		return choiceList.get(rnd.nextInt(choiceList.size()));
	}
}

⇒ 런타임에 ClassEx.. 을 발생시킬 가능성이 없으니 이렇게 변경할 가치가 있음
```<br>

### 되도록 제네릭 타입으로 만들자

---

JDK가 제공하는 제네릭 타입과 메서드를 사용하는 것은 쉬운편이지만, 제네릭 타입을 새로 만드는 것은 어려움<br><br>

```kotlin
public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;
	
	public stack() {
		eletents = new Object[DEFAULT_INITIAL_CAPACITY];
	}
	
	public void push(Object o) {
		ensureCapacity();
		elements[size++] = o;
	}
	
	public Object pop() {
		if (size == 0) {
			throw new EmptyStackException();
		
		Object result = elements[--size];
		elements[size] = null;
		return result;
	}
	
	public boolean isEmpty() {
		return size == 0;
	}
	
	private void ensureCapacity() {
		if (elements.length == size) {
			elements = Arrays.copyOf(elements, 2 * size + 1);
		}
	}
}
```
<br><br>

일반 클래스를 제네릭 클래스로 만드는 첫 단계는 클래스 선언에 타입 매개 변수를 추가하는 것

```kotlin
public class Stack<E> {
	private E[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;
	
	public stack() {
		eletents = new E[DEFAULT_INITIAL_CAPACITY];
	}
	
	public void push(E e) {
		ensureCapacity();
		elements[size++] = e;
	}
	
	public E pop() {
		if (size == 0) {
			throw new EmptyStackException();
		
		E result = elements[--size];
		elements[size] = null;
		return result;
	}
	...
}
```

⇒ 이 단계에서 대체로 하나 이상의 오류나 경고가 발생

⇒ E와 같은 실체화 불가 타입으로는 배열을 만들 수 없음

⇒ 배열을 사용하는 코드를 제네릭으로 만들려 할 때 항상 이 문제가 발생함<br><br>

[ 해결 방법 ]

1. 제네릭 배열 생성을 금지하는 제약을 우회한는 방법
    
    ⇒ 오류 대신 경고를 내보냄 : 타입 안전하지 않음
    
    ```kotlin
    eletents = (E[]) new E[DEFAULT_INITIAL_CAPACITY];
    ```
    <br>
    
    컴파일러는 이 프로그램이 타입 안전한지 증명할 방법이 없지만, 비검사 형변환이 프로그램의 타입 안전성을 해치지 않음을 스스로 확인해야 함
    
    배열 eletents는 private 필드에 저장되고, 클라이언트로 반환되거나 다른 메서드에 전달되는 일이 없음
    
    또한, push 메서드를 통해 배열에 저장되는 원소의 타입은 항상 E이기 때문에 이 비검사 형변환은 안전함<br><br>
    
    비검사 형변환이 안전함을 직접 증명했다면 범위를 최소로 좁혀 @SuppressWarnings 애너테이션으로 해당 경고를 숨기면 됨
    
    ⇒ 생성자가 비검사 배열을 생성 말고는 하는 일이 없으니 생성자 전체에서 경고를 숨기면 됨
    
    ```kotlin
    @SuppressWarnings("unchecked")
    public stack() {
    	eletents = new E[DEFAULT_INITIAL_CAPACITY];
    }
    ```
    <br>
    
2. elements 필드의 타입을 E[]에서 Object[]로 바꾸는 것
    
    ```kotlin
    E result = elements[--size];
    
    여기서 배열이 반환한 원소를 E로 형변환 할 때 오류 대신 경고가 발생
    ```
    
    E는 실체화 불가 타입이므로 컴파일러는 런타입에 이루어지는 형변환이 안전한지 증명할 방법이 없음
    
    ⇒ 직접 안전한지 증명하고 증명된다면 경고를 숨기면 됨
    
    ```kotlin
    	public E pop() {
    		if (size == 0) {
    			throw new EmptyStackException();
    		
    		@SuppressWarnings("unchecked")
    		E result = elements[--size];
    		
    		elements[size] = null;
    		return result;
    	}
    ```
    <br>
    

이렇듯 제네릭 배열을 생성할 수 없는 제약을 우회하는 두 가지 방법은 많이 쓰이지만, 

첫 번째 방법은 가독성이 더 좋으며, 배열의 타입을 E[]로 선언하여 오직 E 타입 인스턴스만 받음을 명시적으로 보여주고 코드가 더 짧으며, 형 변환을 배열 생성 시 단 한 번만 하면 됨

두 번째 방법은 배열에서 원소를 읽을 때마다 형 변환을 해줘야하기 때문에 첫 번째 방법을 더 주로 사용함<br><br>

하지만, 첫 번째 방법은 런타입 타입이 컴파일 타임 타입과 탈라 힙 오염을 일으키기에 두 번째 방법을 쓰기도 함

( 위의 예시는 힙 오염이 일어나지 않았지만 아래의 예를 보자 )

```kotlin
// 명령줄 인수들을 역순으로 바꿔 대문자로 출력하는 프로그램
// Stack에서 꺼낸 원소에서 String의 toUpperCase 메서드를 호출할 때 명시적 형변환을 수행하지 않으며
// , 컴파일러에 의한 자동 형변환이 항상 성공함을 보장함

public static void main(String[] args) {
	Stack<String> stack = new Stack<>();
	
	for (String arg: args) 
		stack.push(arg);
	
	while(!stack.isEmpty()) 
		sout(stack.pop().toUpperCase());
}
```
<br>

앞의 내용에서 보듯이 배열보다는 리스트 사용을 우선시 하라는 것이 제네릭 배열을 우회해서 사용하는데에 있어 모순되어 보이지만 사실 제네릭 타입 안에서 리스트를 사용하는게 항상 가능하지도, 꼭 더 좋은 것도 아님<br><br>

Stack의 예처럼 대다수의 제네릭 타입은 타입 매개변수에 아무런 제약을 두지 않음

⇒ `Stack<Object>` , `Stack<List<String>>` 등 어떤 참조 타입으로도 Stack을 만들 수 있음<br><br>

단, 기본 타입은 사용할 수 없음

⇒ 제네릭 타입의 근본적인 문제이나, 박싱된 기본 타입을 사용하여 우회할 수 있음<br><br>

타입 매개변수에 제약을 두는 제네릭 타입도 존재 ( DelayQueue )

> `class DelayQueue<E extends Delayed> implements BlockingQueue<E>`
> 

⇒ `Delayed`의 하위 타입만 받는다는 의미

⇒ 이는 형 변환 없이 `Delayed` 클래스의 메서드를 호출할 수 있음 ⇒ ClassCastEx.. 발생 걱정을 할 필요가 x

⇒ 이러한 타입 매개변수 E를 `한정적 타입 매개변수`라고 함<br><br>

**결론**

- 클라이언트에서 직접 형변환을 해야하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하기에 새로운 타입을 설계할 때는 형 변환 없이도 사용할 수 있도록 하자
    
    ⇒ 이를 위해서는 제네릭 타입으로 만들어야 할 경우가 많음<br><br>
    

- 기존 타입 중 제네릭이었어야 하는게 있다면 제네릭 타입으로 변경하자
    
    ⇒ 기존 클라이언트에 영향을 주지 않으며, 새로운 사용자를 편하게 해주는 기능임<br><br>
    

### 되도록이면 제네릭 메서드로 만들자

---

클래스와 마찬가지로 메서드도 제네릭으로 만들 수 있음

매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭이며, Collections의 알고리즘 매커니즘 역시 제네릭<br><br>

```kotlin
// 문제가 있는 메서드
public static Set union(Set s1, Set s2) {
	Set result = new HashSet(s1); // 1
	result.addAll(s2); // 2
	return result;
}

컴파일은 되지만 1번, 2번 부분에서 raw 타입 사용에 대한 경고가 발생

경고를 없애기 위해서는 이 메서드를 타입 안전하게 만들어야 함
⇒ 메서드 선언에서의 세 집합 ( 입력 2개, 반환 1개 )의 원소 타입을 타입 매개변수로 명시하고, 메서드 
  안에서도 이 타입 매개변수만 사용하도록 수정하면 됨
  ( 타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 위치 )
  
// 제네릭 메서드
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
	Set<E> result = new HashSet<>(s1); // 1
	result.addAll(s2); // 2
	return result;
}

단순 제네릭 메서드라면 이정도면 충분하며, 경고 없이 컴파일되고 타입 안전함
```

union 메서드는 집합 3개의 타입이 모두 같아야하며, 이를 한정적 와일드카드 타입을 사용하여 더 유연하게 개선할 수 있음<br><br>

때때로 불변 객체를 여러 타입으로 활용할 수 있게 만들어야 할 때가 있음

제네릭은 런타임에 타입 정보가 소거되므로, 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있지만, 이렇게 하기 위해선 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 함

⇒ 제네릭은 컴파일 타임에만 작동하기 때문에 런타임에 타입을 바꾸는 건 불가능하므로 정적 팩터리 메서드로 타입 캐스팅된 인스턴스를 반환해야 함

⇒ 싱글턴 팩터리

```kotlin
// 싱글턴 객체
private static final UnaryOperator<Object> IDENTITY_FN = (x) -> x;

// 정적 제네릭 팩터리 메서드
@SuppressWarnings("unchecked")
public static <T> UnaryOperator<T> identityFunction() {
    return (UnaryOperator<T>) IDENTITY_FN;
}

// 사용 예시 
UnaryOperator<String> sameString = identityFunction();
System.out.println(sameString.apply("hello")); // "hello"

UnaryOperator<Integer> sameInteger = identityFunction();
System.out.println(sameInteger.apply(42)); // 42
```
<br>

항등함수를 담은 클래스를 만든다고 했을 때 ( 원래는 Function.identity를 사용하면 됨 )

항등함수 객체는 상태가 없으니 요청할 때마다 새로 생성하는 것은 낭비이며, 자바의 제네릭이 실체화되면 항등함수를 타입별로 만들어야하지만, 소거 방식을 통한 제네릭 싱글턴을 이용하면 됨

```kotlin
// 위 코드와 같음
IDENTITY_FN를 UnaryOperator<T>로 형변환하면 비검사 형변환 경고가 발생
T가 어떤 타입이든 UnaryOperator<Object>는 UnaryOperator<T>가 아니기 때문

하지만, 항등함수는 입력 값을 수정 없이 그대로 반환하는 특별한 함수이므로, T가 어떤 타입이든 
UnaryOperator<T>를 사용하도 타입 안전함

따라서, 경고를 숨겨도 되므로 코드처럼 @SuppressWarnings("unchecked")를 사용
```
<br>

**재귀적 타입 한정**

`자기 자신이 들어간 표현식을 사용하여 타입 매새변수의 허용 범위를 한정하는 것`

```kotlin
class MyClass<T extends MyClass<T>> {
    ...
}

여기서 T는 반드시 MyClass<T>의 하위 타입이어야함
```
<br>

주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰임

```kotlin
public interface Comparable<T> {
	int compareTo(T o);
}
```

여기서 타입 매개변수 T는 Comparable<T>를 구현한 타입이 비교할 수 있는 원소의 타입을 정의하며 실제로 거의 모든 타입은 자신과 같은 타입의 원소와면 비교할 수 있음

따라서, Comparable<String>을 구현하고 Integer는 Comparable<Integer>를 구현하는 식

```kotlin
public static <E extends Comparable<E>> E max(Collection<E> c);

<E extends Comparable<E>>는 "모든 타입 E는 자신과 비교할 수 있다"라는 의미
```
<br>

```kotlin
컬렉션에 담긴 원소의 자연적 순서를 기준으로 최댓값을 계산하며, 컴파일 오류나 경고는 발생하지 않는 구현
public static <E extends Comparable<E>> E max(Collection<E> c) {
	if(c.isEmpty())
		throw ..
	
	E result = null;
	for (E e: c) 
		if (result == null || e.compareTo(result) > 0)
			result = Objects.requiredNotNull(e);
	
	return result;
}
```
