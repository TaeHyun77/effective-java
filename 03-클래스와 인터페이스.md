### 클래스의 멤버와 접근 권한을 최소화하자

---

잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐임

⇒ 내부 구현 세부사항은 숨기고 다른 컴포넌트는 오직 공개된 API만 보고 사용, 서로의 내부 동작은 간섭 X

⇒ 정보 은닉 또는 캡슐화라고 불림<br><br>

> API : 외부에 공개된 기능을 의미
> 

> 여기서 API의 의미 : 외부에서 접근이 가능하냐 가능하지 않느냐
>
<br><br>

**캡슐화의 장점**

- 시스템 개발 속도를 높인다.
    
    여러 컴포넌트를 병렬적으로 개발할 수 있기 때문
    
- 시스템 관련 비용을 낮춘다.
    
    각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문
    
- 캡슐화가 성능을 높혀주지는 않지만, 최적화에 도움을 줌
    
    만약 어느 컴포넌트를 최적화 하고 싶다면 해당 컴포넌트만 하면 되기 때문
    
- 큰 시스템을 제작하는 난이도를 낮춰줌
    
    시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문<br><br>
    

자바는 이러한 캡슐화를 위한 다양한 장치를 제공하는데, 예를 들어 `접근 제어 매커니즘`임

⇒ 접근 제한자를 제대로 활용하는 것이 캡슐화의 핵심<br><br>

기본적으로 모든 클래스와 멤버의 접근성을 가능한 좁혀야한다 !

탑 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public이며, public으로 선언하면 공개 API가 되고, package-private으로 하면 해당 패키지 안에서만 이용할 수 있음<br><br>

패키지 외부에서 쓸 이유가 없다면 package-private로 선언하자 

⇒ API가 아닌 내부 구현이 되어 언제든 수정 가능

즉, 클라이언트에 아무런 피해 없이 다음 버전에서 수정, 교체, 제거 가능

하지만, public으로 선언한다면 API가 되므로 하위 호환을 위해 관리해줘야만 함<br><br>

**멤버에 부여할 수 있는 접근 제어자**

private : 멤버를 선언한 클래스에서만 접근 가능

package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 ( default )

( 인터페이스 멤버는 기본적으로 public )

protected : package-private의 범위를 포함하며, 다른 패키지더라도 하위 클래스에서는 접근 가능

public : 모든 곳에서 접근 가능<br><br>

**멤버 접근성을 최대한 줄이는 것이 좋지만, 이를 못하게 하는 제약이 하나 존재**

상위 클래스의 메서드를 재정의할 때, 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없는 것 ( 멤버는 제외 )

⇒ 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙

( 만약 상위 클래스의 접근 제어가 하위보다 넓다면 안되기 때문 - 리스코프 치환 원칙 )<br><br>

예외적으로 인터페이스를 구현한 클래스는 메서드를 반드시 public으로 선언해야 함<br><br>

**public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함**

필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됨

⇒ 이 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다는 의미 ( 외부에서 무시할 수 있기 때문 )

> 불변식 : 클래스가 항상 지켜야 하는 상태 조건
>
<br><br>

또한, 필드가 수정될 때 ( 예를 들어 락 ) 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않음

( public 가변 필드는 외부에서 락( lock ) 없이도 동시에 변경이 가능하기 때문 )<br><br>

하지만, 예외가 한 가지 있음 : 상수 ( public static final ) - 반드시 불변 객체나 기본 타입 값을 참조해야 함<br><br>

클래스에서 public static final 배열 필드를 두거나, 이 필드를 반환하는 접근자 메서드를 제공해서는 안됨

⇒ 이 배열의 내용을 수정할 수 있기 때문<br><br>

**자바 9에서의 모듈 시스템**

패키지가 클래스들의 묶음이듯이, 모듈은 패키지들의 묶음

모듈은 자신에 속하는 패키지 중 공개 가능할 것들을 선언하는데, protected, public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없음 ( 물론 모듈 안에서는 영향을 받지 않음 )

모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공개할 수 있음<br><br>

모듈에서 숨겨진 패키지 안에 있는 public, protected 접근 제어자는 전체가 모듈 안에서만 각각 public, protected 수준의 접근 수준을 가짐 

⇒ 모듈 내부로 한정되는 것<br><br>

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하자

---

때떄로 인스턴스 필드들만 모아놓는 클래스를 작성할 때가 있는데, 이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못함

```kotlin
class Point {
	public double x;
	public double y;
}
```
<br>

API를 수정하지 않고는 내부 표현을 바꿀 수도 없고, 불변식을 보장할 수도 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없음

따라서, 필드를 private로 바꾸고 public 접근자를 추가 ( getter ) 

```kotlin
class Point {
	private double x;
	private double y;

	public Point(double x, double y) {
		this.x = x;
		this.y = y;
	}
	
	public double getX() { return this.x; }
	public double getY() { return this.t; }
	
	public void setX(double x) { this.x = x; }
	public void setY(double y) { this.y = y; }
}
```
<br>

하지만, package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 문제가 없음

⇒ 외부에서 이 클래스에 접근할 수 없기 때문

이 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 됨<br><br>

public 클래스의 필드가 불변이라면 직접 노출할 때의 단점이 조금은 줄어들지만, 결코 좋은 생각은 아님

API를 변경하지 않고는 표현의 방식을 변경할 수 없고, 필드를 읽을 때 부수작업을 수행할 수 없기 때문<br><br>

각 인스턴스가 유효한 시간을 표현함을 보장하는 코드

```kotlin
public final class Time {
	private static final int HOURS_PER_DAY = 24;
	private static final int MINUTES_PER_HOUR = 60;
	
	public final int hour;
	public final int minute;
	
	public Time(int hour, int minute) {
		if (hour < 0 || hour >= HOURS_PER_DAY) 
			throw new Ex..
		if (minute < 0 || minute >= MINUTES_PER_HOUR) 
			throw Ex ..
			
		this.hour = hour;
		this.minute = minute;
	}
}
```
<br>

결론적으로 public 클래스는 절대 가변 필드를 직접 노출해서는 안되고, 불변 필드라면 덜 위험할 것 같지만 웬만하면 사용하지 않는 것이 좋음

하지만, package-private 클래스 혹은 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있음

⇒ 무조건 캡슐화 하는 것보다 클래스가 외부에 노출되지 않는 경우에는 필드를 노출하는게 더 효율적일 수 있음 

⇒ 굳이 getter, setter 사용하지 않아도 되는 등등 ..<br><br>

### 변경 가능성을 최소화하자

---

> 불변 클래스 : 인스턴스의 내부 값을 수정할 수 없는 클래스
> 

ex ) String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal …<br><br>

**불변 클래스를 사용하는 이유**

가변 클래스보다 설계하고 구현하기 쉬으며, 오류가 발생도 적고 안전하기 때문<br><br>

**클래스를 불변으로 만드는 다섯가지 원칙**

1. 객체의 상태를 변경하는 메서드 ( setter )를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다 ( 클래스를 final로 선언 or 이후 한 가지 방법 더 나옴 )
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private로 선언한다.
    
    외부 코드가 직접 접근 / 수정하지 못하게 막음
    
    기본 타입 필드나 불변 객체를 참조하는 필드를 public final로 선언만 해도 불변 객체가 되지만, 나중에 내부 표현을 바꾸지 못하게 될 수 있으니 권하지는 않음<br><br>
    
    > 내부 표현 : 클래스 내부에서 데이터를 저장하는 방식, 구조, 타입을 의미
    > 
    
    ```kotlin
    public class Money {
        public final int amount;
    }
    
    ⇒ public 이므로 외부에서 접근할 수 있음
    
    만약 int를 다른 타입으로 바꾸고 싶다면 바꾸는 순간, 외부 코드들 전부 에러 → 리팩터링 해야함
    
    따라서, 필드를 private로 선언하고, getter를 통해 접근할 수 있도록 하는 것이 좋음
    ```
    <br>
    
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    
    클래스에서 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 함
    
    ⇒ 생성자, 접근자 모두에서 방어적 복사를 하자<br><br>
    

**원칙에 의한 예제**

```kotlin
public final class Complex {
	private final double re;
	private final double im;
	
	public Complex (double re, double im) {
		this.re = re;
		this.im = im;
	}
	
	public double getRe() { return re; }
	public double getIm() { return im; }
	
	public Complex plus(Complex c) {
		return new Complex(re + c.re, im + c.im);
	}
	
	public Complex minus(Complex c) {
		return new Complex(re - c.re, im - c.im);
	}
	
	public Complex times(Complex c) {
		return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
	}
	
	@Override 
	public boolean equals(Object o) {
	
		if ( this == o ) return true;
		if ( !(o instanceOf Complex) ) return false;
		
		return Double.compare(re, c.re) == 0 && Double.compare(im, c.im) == 0;
	}
	
	@Override
	public int hashCode() {
		return 31 * Double.hashCode(re) + Double.hashCode(im);
	}
	
	@Override public String toString() {
		return "(" + re " " + " + im + "i)";
	}	
```

사칙연산 메서드들은 인스턴스 자신을 수정하지 않고 새로운 인스턴스를 생성하여 반환함

⇒ 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 패턴 : 함수형 프로그래밍<br><br>

이와 달리, 절차적 혹은 명령형 프로그래밍에서는 메서드에서 피연산자인 자신이 수정되어 자신의 상태가 변하게됨

또한, 메서드 명을 add와 같은 동사가 아닌 plus와 같은 전치사를 사용한 이유도 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조한 의도임

이런 식으로 함수형 프로그래밍을 사용한다면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 얻을 수 있음<br><br>

불변 객체는 근본적으로 여러 스레드가 동시에 사용해도 절대 훼손되지 않으므로 스레드 안전함 !

따라서, 불변 객체는 안심하고 공유할 수 있으며, 만약 불변 클래스를 만들었다면 한 번 만든 인스턴스를 최대한 재활용하는 것이 좋음

ex ) 상수<br><br>

불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있음

ex ) 박싱된 기본 타입 클래스들과 BigInteger가 여기에 속함

⇒ -128 ~ 127 범위는 내부 캐시에서 재사용하며, BigInteger 내부에는 여러 정적 팩터리를 제공함

이러한 정적 팩터리를 사용하면 여러 클라이어트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 ↓<br><br>

**불변 객체는 자유롭게 공유할 수 있으며, 불변 객체끼리는 내부 데이터를 공유할 수 있음**

```kotlin
List<String> commonList = List.of("A", "B");

User u1 = new User("Alice", commonList);
User u2 = new User("Bob", commonList);

// 가변 객체였다면 한 쪽에서 수정했을 때 다른 쪽에도 영향이 가지만, 불변 객체이기 때문에 상관 없음
```
<br>

**객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음**<br><br>

**불변 객체는 그 자체로 실패 원자성을 제공**

> 실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태이어야 한다는 성질
>
<br><br>

**불변 클래스에도 단점은 존재**

값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이며, 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용을 치뤄야 한다는 점<br><br>

**클래스가 불변임을 보장하기 위해 final로 선언할 수도 있지만, 다른 방법도 존재**

모든 생성자를 private 혹은 package-private로 만들고, public 정적 팩터리를 제공하는 방법<br><br>

왜 생성자를 private로 바꿀까 : 하위 클래스에서는 super() 호출이 안 되므로 사실상 상속이 안됨<br><br>

```kotlin
public class Complex {
	private final double re;
	private final double im;
	
	private Complex(double rm, double im) {
		this.re = re;
		this.im = im;
	}
	
	public static Complex valueOf(double rm, double im) {
		return new Complex(rm, im);
	}
}
```
<br>

불변 클래스의 규칙에서 모든 필드는 final이어야 하고, 어떤 메서드도 그 객체를 수정할 수 없다고 하였는데, 성능을 위해 조금은 완화할 수 있음

⇒ 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다.<br><br>

어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시 해놓기도 하는데, 이는 불변 객체는 내부 상태가 절대 바뀌지 않기 때문에, 한 번 계산된 값( ex. hashCode )을 안전하게 캐시해도 논리적 불변성이 유지됨

⇒ 불변 객체이기 때문에 가능한 것

⭐️ 가변 객체는 중간에 값이 바뀔 수 있기 때문에, hashCode() 같은 결과를 캐싱하는 전략을 사용할 수 없음 ⭐️<br><br>

**정리해보자면**

- getter가 있다고 해서 항상 setter가 있을 필요는 없으며, 클래스는 꼭 필요한 경우가 아니라면 불변이어야 함
- 단순한 값 객체 클래스는 웬만하면 불변 클래스로 만들자
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
    
    ⇒ 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어듦
    
    ⇒ 합당한 이유가 없다면 모든 필드는 private final이어야 함<br><br>
    
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 함
    
    ⇒ 객체의 모든 필드가 완전하고 올바른 값으로 세팅되어 있어야 한다는 의미
    
    ⇒ 즉, 객체 생성 후에는 절대 불완전한 상태가 되어서는 안됨 ( 객체 만들고 setter로 나중에 완성해야지 ❌ )
    
    확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안됨
    
    ⇒ 객체를 생성한 후에, 값을 설정하는 메서드 ( setter  등등 )을 외부에서 쓸 수 있게 하지마라는 의미<br><br>

### 상속을 고려하여 설계화하고 문서화하자 - 그러지 않는다면 상속을 금지하자

---

**상속을 고려한 설계와 문서화란 무엇일까**

메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서로 남겨야함

클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수 있고, 마침 호출되는 메서드가 재정의 된 메서드라면 호출하는 메서드의 API 설명에 명시하여야 함

추가적으로, 어떤 순서로 호출되는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 명시

더 넓게 말하면, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨놔야 함

⇒ 메서드 주석에 `@implSpec` 태그를 붙여 생성<br><br>

**상속용 클래스를 설계할 때, 어떤 메서드를 private로 숨기고, 어떤 메서드를 protecte로 열어줄지 결정해야 함**

protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야하며, 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 함

즉, 너무 많은 메서드를 protected로 열면 하위 클래스가 상위 클래스 내부 구조에 너무 의존하게 되므로 최대한 줄여야하며 반대로 다 private로 하면 상속의 이점이 사라지므로 잘 조절해야 한다는 의미<br><br>

널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과, protected 메서드와 필드를 잘 구현하면서 선택한 결정을 책임져야 함

⇒ 이러한 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있기 때문<br><br>

**상속용 클래스의 생성자는 직, 간접적으로 재정의 가능 메서드를 호출해서는 안됨**

상위 클래스에서 호출된 메서드가, 하위 클래스에서 재정의한 메서드라면, 그 메서드 안에서 사용하는 값들이 아직 초기화되지 않았을 수 있음

```kotlin
public class Super {
	public Super() {
		overrideMe();
	}
	
	public void overrideMe() {
	}
}

---

public final class Sub extends Super {
	private final Instant instant;
	
	Sub() {
		instant = Instant.now();
	}
	
	@Override
	public void overrideMe() {
		sout(instant);
	}
	
	public static void main(String[] args) {
		Sub sub = new Sub();
		sub.overrideMe();
	}
}
```
<br>

Sub의 객체를 만들게 되면 상위 클래스인 Super 먼저 생성자가 호출되는데 이때 Super 생성자 안의 overrideMe()는 Sub의 overrideMe()를 가르키게 되고, 이 시점에서는 instant가 초기화 되지 않았으므로 null이 출력되게 됨<br><br>

**일반적인 구체 클래스는 어떨까**

전통적으로 이런 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않았지만, 그래도 두면 위험함

클래스에 변화가 생길 때마다 하위 클래스를 오작동하게 만들 수 있기 때문 .. .. <br><br>

`이러한 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것`<br><br>

**상속을 금지하는 두 가지 방법**

1. 클래스를 final로 선언하는 방법
2. 모든 생성자를 private, package-private로 선언하고, public 정적 팩터리를 만들어주는 것<br><br>

핵심 기능을 정의한 인터페이스가 있고, 클래스가 그 인터페이스를 구현했다면 상속을 금지해도 개발하는데에는 아무런 어려움이 없음

ex) Set, List, Map …<br><br>

래퍼 클래스 역시 상속 대신 쓸 수 있는 더 나은 대안이기도 함<br><br>

**구체 클래스가 표준 인터페이스를 구현하지 않았는데, 상속을 금지한다면 사용하기에 상당히 불변해짐**

이런 클래스라도 상속을 꼭 허용해야한다면 합당한 방법이 하나 존재

⇒ 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것<br><br>

위 방법을 사용한다면 상속을 이용한다 해도 그리 위험하지는 않은 클래스를 만들 수 있음

→ 메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않기 때문<br><br>

**재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법**

각각의 재정의 가능 메서드는 자신의 본문 코드를 private 도우미 메서드로 옮기고, 이 도우미 메서드를 호출하도록 수정한 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정<br><br>

**결론적으로**

상속용 클래스를 설계할 때는 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 한다.

그렇지 않으면 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있음<br><br>

상속을 금지하려면 클래스를 final로 선언하거나 생성자를 외부에서 접근하지 못하도록 만들면 됨<br><br>

### 추상 클래스보다는 인터페이스를 우선시하자

---

자바의 다중 구현 매커니즘은 인터페이스와 추상 클래스가 존재

자바 8부터는 인터페이스도 default 메서드를 제공할 수 있게 되어, 두 매커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있음<br><br>

한편 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점

⇒ 추상 클래스 방식은 `단일 상속만 가능하기에` 새로운 타입을 정의하는데 제약을 얻게 됨<br><br>

반면, 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속하던 같은 타입으로 취급됨

⇒ 어떤 클래스를 상속 받더라도 인터페이스를 구현한다면 그 인터페이스의 타입으로 간주됨<br><br>

**인터페이스는 `믹스인` 정의에 안성맞춤임**

> 믹스인 : 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에 도 특정 선택적 행위를 제공한다고 선언하는 효과를 줌
> 

`믹스인은 기존 클래스에 수직 계층 구조와 무관하게 부착되어야 함`

`즉, 클래스 상속과는 별개로 끼워 넣을 수 있는 것이 중요`

ex ) Comparable은 자신을 구현한 클래스의 인스턴스끼리는 순서를 정할 수 있다고 선언하는 믹스인 interface<br><br>

**추상 클래스로는 믹스인을 정의할 수 없음**

why ) 기존 클래스에 덧씌울 수 없기 때문

자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있으면 추상 클래스를 상속 받을 수 없음

클래스는 두 부모를 섬길 수 없고, 믹스인은 계층 구조에 얽매이지 않아야 하는데, 클래스 계층 구조에는 믹스인을 삽입하기에 합리적인 위치가 없기 때문<br><br>

**인터페이스는 계층 구조가 없는 타입 프레임워크를 만들 수 있음**

인터페이스는 계층 구조 없이도 타입을 표현할 수 있다.

하지만, 클래스 상속은 항상 계층 구조에 기반하므로 현실의 복잡한 개념을 담기에 한계가 존재함<br><br>

```kotlin
public interface Singer {
	AudioClip sing(Song s);
}

public interface SongWriter {
	Song compose(int chartPosition);
}
```

작곡도 하는 가수가 있는데, 이 코드처럼 인터페이스로 정의하면 가수 클래스가 Singer와 SongWriter를 모두 구현해도 아무런 문제가 없음

심지어, Singer와 SongWriter 모두를 확장하고, 새로운 메서드까지 추가한 새 인터페이스를 정의할 수도있음<br><br>

**하지만, 이러한 구조를 클래스로 만들기 위해서는 아주 복잡함**

상속은 한 개만 가능하기에 위처럼 작곡을 하는 가수를 표현하기가 곤란함 

즉, 여러가지의 기능을 표현하는 방법을 사용하기에 클래스 구조는 적합하지 않음<br><br>

**결론적으로**

추상 클래스나 일반 클래스 상속을 통해 타입을 정의하면, 하나의 고정된 구조로만 표현이 가능하지만

, 현실 세계의 개념은 여러 타입이 겹치거나 혼합된느 경우가 많으므로 이는 적합하지 않음<br><br>

하지만, 인터페이스는 계층 구조 없이도 타입을 유연하게 표현 가능하므로 이러한 설계를 할 때는 인터페이스를 이용하는 것이 좋음
