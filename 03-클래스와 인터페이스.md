### 클래스의 멤버와 접근 권한을 최소화하자

---

잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐임

내부 구현 세부사항은 숨기고 다른 컴포넌트는 오직 공개된 API만 보고 사용, 서로의 내부 동작은 간섭 X

⇒ 정보 은닉 또는 캡슐화라고 불림<br><br>

> API : 외부에 공개된 기능을 의미
> 

> 여기서 API의 의미 : 외부에서 접근이 가능하냐 가능하지 않느냐
>
<br><br>

**캡슐화의 장점**

- 시스템 개발 속도를 높인다.
    
    여러 컴포넌트를 병렬적으로 개발할 수 있기 때문
    
- 시스템 관련 비용을 낮춘다.
    
    각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문
    
- 캡슐화가 성능을 높혀주지는 않지만, 최적화에 도움을 줌
    
    만약 어느 컴포넌트를 최적화 하고 싶다면 해당 컴포넌트만 하면 되기 때문
    
- 큰 시스템을 제작하는 난이도를 낮춰줌
    
    시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문<br><br>
    

자바는 이러한 캡슐화를 위한 다양한 장치를 제공하는데, 예를 들어 `접근 제어 매커니즘`임

⇒ 접근 제한자를 제대로 활용하는 것이 캡슐화의 핵심<br><br>

기본적으로 모든 클래스와 멤버의 접근성을 가능한 좁혀야한다 !

탑 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public이며, public으로 선언하면 공개 API가 되고, package-private으로 하면 해당 패키지 안에서만 이용할 수 있음<br><br>

패키지 외부에서 쓸 이유가 없다면 package-private로 선언하자 

⇒ API가 아닌 내부 구현이 되어 언제든 수정 가능

즉, 클라이언트에 아무런 피해 없이 다음 버전에서 수정, 교체, 제거 가능

하지만, public으로 선언한다면 API가 되므로 하위 호환을 위해 관리해줘야만 함<br><br>

**멤버에 부여할 수 있는 접근 제어자**

private : 멤버를 선언한 클래스에서만 접근 가능

package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 ( default )

( 인터페이스 멤버는 기본적으로 public )

protected : package-private의 범위를 포함하며, 다른 패키지더라도 하위 클래스에서는 접근 가능

public : 모든 곳에서 접근 가능<br><br>

**멤버 접근성을 최대한 줄이는 것이 좋지만, 이를 못하게 하는 제약이 하나 존재**

상위 클래스의 메서드를 재정의할 때, 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없는 것 ( 멤버는 제외 )

⇒ 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙

( 만약 상위 클래스의 접근 제어가 하위보다 넓다면 안되기 때문 - 리스코프 치환 원칙 )<br><br>

예외적으로 인터페이스를 구현한 클래스는 메서드를 반드시 public으로 선언해야 함<br><br>

**public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함**

필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됨

⇒ 이 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다는 의미 ( 외부에서 무시할 수 있기 때문 )

> 불변식 : 클래스가 항상 지켜야 하는 상태 조건
>
<br><br>

또한, 필드가 수정될 때 ( 예를 들어 락 ) 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않음

( public 가변 필드는 외부에서 락( lock ) 없이도 동시에 변경이 가능하기 때문 )<br><br>

하지만, 예외가 한 가지 있음 : 상수 ( public static final ) - 반드시 불변 객체나 기본 타입 값을 참조해야 함<br><br>

클래스에서 public static final 배열 필드를 두거나, 이 필드를 반환하는 접근자 메서드를 제공해서는 안됨

⇒ 이 배열의 내용을 수정할 수 있기 때문<br><br>

**자바 9에서의 모듈 시스템**

패키지가 클래스들의 묶음이듯이, 모듈은 패키지들의 묶음

모듈은 자신에 속하는 패키지 중 공개 가능할 것들을 선언하는데, protected, public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없음 ( 물론 모듈 안에서는 영향을 받지 않음 )

모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공개할 수 있음<br><br>

모듈에서 숨겨진 패키지 안에 있는 public, protected 접근 제어자는 전체가 모듈 안에서만 각각 public, protected 수준의 접근 수준을 가짐 

⇒ 모듈 내부로 한정되는 것<br><br>

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하자

---

때떄로 인스턴스 필드들만 모아놓는 클래스를 작성할 때가 있는데, 이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못함

```kotlin
class Point {
	public double x;
	public double y;
}
```
<br>

API를 수정하지 않고는 내부 표현을 바꿀 수도 없고, 불변식을 보장할 수도 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없음

따라서, 필드를 private로 바꾸고 public 접근자를 추가 ( getter ) 

```kotlin
class Point {
	private double x;
	private double y;

	public Point(double x, double y) {
		this.x = x;
		this.y = y;
	}
	
	public double getX() { return this.x; }
	public double getY() { return this.t; }
	
	public void setX(double x) { this.x = x; }
	public void setY(double y) { this.y = y; }
}
```
<br>

하지만, package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 문제가 없음

⇒ 외부에서 이 클래스에 접근할 수 없기 때문

이 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 됨<br><br>

public 클래스의 필드가 불변이라면 직접 노출할 때의 단점이 조금은 줄어들지만, 결코 좋은 생각은 아님

API를 변경하지 않고는 표현의 방식을 변경할 수 없고, 필드를 읽을 때 부수작업을 수행할 수 없기 때문<br><br>

각 인스턴스가 유효한 시간을 표현함을 보장하는 코드

```kotlin
public final class Time {
	private static final int HOURS_PER_DAY = 24;
	private static final int MINUTES_PER_HOUR = 60;
	
	public final int hour;
	public final int minute;
	
	public Time(int hour, int minute) {
		if (hour < 0 || hour >= HOURS_PER_DAY) 
			throw new Ex..
		if (minute < 0 || minute >= MINUTES_PER_HOUR) 
			throw Ex ..
			
		this.hour = hour;
		this.minute = minute;
	}
}
```
<br>

**결론**

public 클래스는 절대 가변 필드를 직접 노출해서는 안되고, 불변 필드라면 덜 위험할 것 같지만 웬만하면 사용하지 않는 것이 좋음

하지만, package-private 클래스 혹은 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있음

⇒ 무조건 캡슐화 하는 것보다 클래스가 외부에 노출되지 않는 경우에는 필드를 노출하는게 더 효율적일 수 있음 

⇒ 굳이 getter, setter 사용하지 않아도 되는 등등 ..<br><br>

### 변경 가능성을 최소화하자

---

> 불변 클래스 : 인스턴스의 내부 값을 수정할 수 없는 클래스
> 

ex ) String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal …<br><br>

**불변 클래스를 사용하는 이유**

가변 클래스보다 설계하고 구현하기 쉬으며, 오류가 발생도 적고 안전하기 때문<br><br>

**클래스를 불변으로 만드는 다섯가지 원칙**

1. 객체의 상태를 변경하는 메서드 ( setter )를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다 ( 클래스를 final로 선언 or 이후 한 가지 방법 더 나옴 )
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private로 선언한다.
    
    외부 코드가 직접 접근 / 수정하지 못하게 막음
    
    기본 타입 필드나 불변 객체를 참조하는 필드를 public final로 선언만 해도 불변 객체가 되지만, 나중에 내부 표현을 바꾸지 못하게 될 수 있으니 권하지는 않음<br><br>
    
    > 내부 표현 : 클래스 내부에서 데이터를 저장하는 방식, 구조, 타입을 의미
    > 
    
    ```kotlin
    public class Money {
        public final int amount;
    }
    
    ⇒ public 이므로 외부에서 접근할 수 있음
    
    만약 int를 다른 타입으로 바꾸고 싶다면 바꾸는 순간, 외부 코드들 전부 에러 → 리팩터링 해야함
    
    따라서, 필드를 private로 선언하고, getter를 통해 접근할 수 있도록 하는 것이 좋음
    ```
    <br>
    
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    
    클래스에서 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 함
    
    ⇒ 생성자, 접근자 모두에서 방어적 복사를 하자<br><br>
    

**원칙에 의한 예제**

```kotlin
public final class Complex {
	private final double re;
	private final double im;
	
	public Complex (double re, double im) {
		this.re = re;
		this.im = im;
	}
	
	public double getRe() { return re; }
	public double getIm() { return im; }
	
	public Complex plus(Complex c) {
		return new Complex(re + c.re, im + c.im);
	}
	
	public Complex minus(Complex c) {
		return new Complex(re - c.re, im - c.im);
	}
	
	public Complex times(Complex c) {
		return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
	}
	
	@Override 
	public boolean equals(Object o) {
	
		if ( this == o ) return true;
		if ( !(o instanceOf Complex) ) return false;
		
		return Double.compare(re, c.re) == 0 && Double.compare(im, c.im) == 0;
	}
	
	@Override
	public int hashCode() {
		return 31 * Double.hashCode(re) + Double.hashCode(im);
	}
	
	@Override public String toString() {
		return "(" + re " " + " + im + "i)";
	}	
```

사칙연산 메서드들은 인스턴스 자신을 수정하지 않고 새로운 인스턴스를 생성하여 반환함

⇒ 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 패턴 : 함수형 프로그래밍<br><br>

이와 달리, 절차적 혹은 명령형 프로그래밍에서는 메서드에서 피연산자인 자신이 수정되어 자신의 상태가 변하게됨

또한, 메서드 명을 add와 같은 동사가 아닌 plus와 같은 전치사를 사용한 이유도 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조한 의도임

이런 식으로 함수형 프로그래밍을 사용한다면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 얻을 수 있음<br><br>

불변 객체는 근본적으로 여러 스레드가 동시에 사용해도 절대 훼손되지 않으므로 스레드 안전함 !

따라서, 불변 객체는 안심하고 공유할 수 있으며, 만약 불변 클래스를 만들었다면 한 번 만든 인스턴스를 최대한 재활용하는 것이 좋음

ex ) 상수<br><br>

불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있음

ex ) 박싱된 기본 타입 클래스들과 BigInteger가 여기에 속함

⇒ -128 ~ 127 범위는 내부 캐시에서 재사용하며, BigInteger 내부에는 여러 정적 팩터리를 제공함

이러한 정적 팩터리를 사용하면 여러 클라이어트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 ↓<br><br>

**불변 객체는 자유롭게 공유할 수 있으며, 불변 객체끼리는 내부 데이터를 공유할 수 있음**

```kotlin
List<String> commonList = List.of("A", "B");

User u1 = new User("Alice", commonList);
User u2 = new User("Bob", commonList);

// 가변 객체였다면 한 쪽에서 수정했을 때 다른 쪽에도 영향이 가지만, 불변 객체이기 때문에 상관 없음
```
<br>

**객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음**<br><br>

**불변 객체는 그 자체로 실패 원자성을 제공**

> 실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태이어야 한다는 성질
>
<br><br>

**불변 클래스에도 단점은 존재**

값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이며, 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용을 치뤄야 한다는 점<br><br>

**클래스가 불변임을 보장하기 위해 final로 선언할 수도 있지만, 다른 방법도 존재**

모든 생성자를 private 혹은 package-private로 만들고, public 정적 팩터리를 제공하는 방법<br><br>

왜 생성자를 private로 바꿀까 : 하위 클래스에서는 super() 호출이 안 되므로 사실상 상속이 안됨<br><br>

```kotlin
public class Complex {
	private final double re;
	private final double im;
	
	private Complex(double rm, double im) {
		this.re = re;
		this.im = im;
	}
	
	public static Complex valueOf(double rm, double im) {
		return new Complex(rm, im);
	}
}
```
<br>

불변 클래스의 규칙에서 모든 필드는 final이어야 하고, 어떤 메서드도 그 객체를 수정할 수 없다고 하였는데, 성능을 위해 조금은 완화할 수 있음

⇒ 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다.<br><br>

어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시 해놓기도 하는데, 이는 불변 객체는 내부 상태가 절대 바뀌지 않기 때문에, 한 번 계산된 값( ex. hashCode )을 안전하게 캐시해도 논리적 불변성이 유지됨

⇒ 불변 객체이기 때문에 가능한 것

⭐️ 가변 객체는 중간에 값이 바뀔 수 있기 때문에, hashCode() 같은 결과를 캐싱하는 전략을 사용할 수 없음 ⭐️<br><br>

**정리해보자면**

- getter가 있다고 해서 항상 setter가 있을 필요는 없으며, 클래스는 꼭 필요한 경우가 아니라면 불변이어야 함
- 단순한 값 객체 클래스는 웬만하면 불변 클래스로 만들자
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
    
    ⇒ 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어듦
    
    ⇒ 합당한 이유가 없다면 모든 필드는 private final이어야 함<br><br>
    
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 함
    
    ⇒ 객체의 모든 필드가 완전하고 올바른 값으로 세팅되어 있어야 한다는 의미
    
    ⇒ 즉, 객체 생성 후에는 절대 불완전한 상태가 되어서는 안됨 ( 객체 만들고 setter로 나중에 완성해야지 ❌ )
    
    확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안됨
    
    ⇒ 객체를 생성한 후에, 값을 설정하는 메서드 ( setter  등등 )을 외부에서 쓸 수 있게 하지마라는 의미<br><br>

### 상속을 고려하여 설계화하고 문서화하자 - 그러지 않는다면 상속을 금지하자

---

**상속을 고려한 설계와 문서화란 무엇일까**

메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서로 남겨야함

클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수 있고, 마침 호출되는 메서드가 재정의 된 메서드라면 호출하는 메서드의 API 설명에 명시하여야 함

추가적으로, 어떤 순서로 호출되는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 명시

더 넓게 말하면, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨놔야 함

⇒ 메서드 주석에 `@implSpec` 태그를 붙여 생성<br><br>

**상속용 클래스를 설계할 때, 어떤 메서드를 private로 숨기고, 어떤 메서드를 protecte로 열어줄지 결정해야 함**

protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야하며, 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 함

즉, 너무 많은 메서드를 protected로 열면 하위 클래스가 상위 클래스 내부 구조에 너무 의존하게 되므로 최대한 줄여야하며 반대로 다 private로 하면 상속의 이점이 사라지므로 잘 조절해야 한다는 의미<br><br>

널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과, protected 메서드와 필드를 잘 구현하면서 선택한 결정을 책임져야 함

⇒ 이러한 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있기 때문<br><br>

**상속용 클래스의 생성자는 직, 간접적으로 재정의 가능 메서드를 호출해서는 안됨**

상위 클래스에서 호출된 메서드가, 하위 클래스에서 재정의한 메서드라면, 그 메서드 안에서 사용하는 값들이 아직 초기화되지 않았을 수 있음

```kotlin
public class Super {
	public Super() {
		overrideMe();
	}
	
	public void overrideMe() {
	}
}

---

public final class Sub extends Super {
	private final Instant instant;
	
	Sub() {
		instant = Instant.now();
	}
	
	@Override
	public void overrideMe() {
		sout(instant);
	}
	
	public static void main(String[] args) {
		Sub sub = new Sub();
		sub.overrideMe();
	}
}
```
<br>

Sub의 객체를 만들게 되면 상위 클래스인 Super 먼저 생성자가 호출되는데 이때 Super 생성자 안의 overrideMe()는 Sub의 overrideMe()를 가르키게 되고, 이 시점에서는 instant가 초기화 되지 않았으므로 null이 출력되게 됨<br><br>

**일반적인 구체 클래스는 어떨까**

전통적으로 이런 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않았지만, 그래도 두면 위험함

클래스에 변화가 생길 때마다 하위 클래스를 오작동하게 만들 수 있기 때문 .. .. <br><br>

`이러한 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것`<br><br>

**상속을 금지하는 두 가지 방법**

1. 클래스를 final로 선언하는 방법
2. 모든 생성자를 private, package-private로 선언하고, public 정적 팩터리를 만들어주는 것<br><br>

핵심 기능을 정의한 인터페이스가 있고, 클래스가 그 인터페이스를 구현했다면 상속을 금지해도 개발하는데에는 아무런 어려움이 없음

ex) Set, List, Map …<br><br>

래퍼 클래스 역시 상속 대신 쓸 수 있는 더 나은 대안이기도 함<br><br>

**구체 클래스가 표준 인터페이스를 구현하지 않았는데, 상속을 금지한다면 사용하기에 상당히 불변해짐**

이런 클래스라도 상속을 꼭 허용해야한다면 합당한 방법이 하나 존재

⇒ 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것<br><br>

위 방법을 사용한다면 상속을 이용한다 해도 그리 위험하지는 않은 클래스를 만들 수 있음

→ 메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않기 때문<br><br>

**재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법**

각각의 재정의 가능 메서드는 자신의 본문 코드를 private 도우미 메서드로 옮기고, 이 도우미 메서드를 호출하도록 수정한 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정<br><br>

**결론**

상속용 클래스를 설계할 때는 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 한다.

그렇지 않으면 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있음<br><br>

상속을 금지하려면 클래스를 final로 선언하거나 생성자를 외부에서 접근하지 못하도록 만들면 됨<br><br>

### 추상 클래스보다는 인터페이스를 우선시하자

---

자바의 다중 구현 매커니즘은 인터페이스와 추상 클래스가 존재

자바 8부터는 인터페이스도 default 메서드를 제공할 수 있게 되어, 두 매커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있음<br><br>

한편 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점

⇒ 추상 클래스 방식은 `단일 상속만 가능하기에` 새로운 타입을 정의하는데 제약을 얻게 됨<br><br>

반면, 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속하던 같은 타입으로 취급됨

⇒ 어떤 클래스를 상속 받더라도 인터페이스를 구현한다면 그 인터페이스의 타입으로 간주됨<br><br>

**인터페이스는 `믹스인` 정의에 안성맞춤임**

> 믹스인 : 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에 도 특정 선택적 행위를 제공한다고 선언하는 효과를 줌
> 

`믹스인은 기존 클래스에 수직 계층 구조와 무관하게 부착되어야 함`

`즉, 클래스 상속과는 별개로 끼워 넣을 수 있는 것이 중요`

ex ) Comparable은 자신을 구현한 클래스의 인스턴스끼리는 순서를 정할 수 있다고 선언하는 믹스인 interface<br><br>

**추상 클래스로는 믹스인을 정의할 수 없음**

why ) 기존 클래스에 덧씌울 수 없기 때문

자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있으면 추상 클래스를 상속 받을 수 없음

클래스는 두 부모를 섬길 수 없고, 믹스인은 계층 구조에 얽매이지 않아야 하는데, 클래스 계층 구조에는 믹스인을 삽입하기에 합리적인 위치가 없기 때문<br><br>

**인터페이스는 계층 구조가 없는 타입 프레임워크를 만들 수 있음**

인터페이스는 계층 구조 없이도 타입을 표현할 수 있다.

하지만, 클래스 상속은 항상 계층 구조에 기반하므로 현실의 복잡한 개념을 담기에 한계가 존재함<br><br>

```kotlin
public interface Singer {
	AudioClip sing(Song s);
}

public interface SongWriter {
	Song compose(int chartPosition);
}
```

작곡도 하는 가수가 있는데, 이 코드처럼 인터페이스로 정의하면 가수 클래스가 Singer와 SongWriter를 모두 구현해도 아무런 문제가 없음

심지어, Singer와 SongWriter 모두를 확장하고, 새로운 메서드까지 추가한 새 인터페이스를 정의할 수도있음<br><br>

**하지만, 이러한 구조를 클래스로 만들기 위해서는 아주 복잡함**

상속은 한 개만 가능하기에 위처럼 작곡을 하는 가수를 표현하기가 곤란함 

즉, 여러가지의 기능을 표현하는 방법을 사용하기에 클래스 구조는 적합하지 않음<br><br>

**결론**

추상 클래스나 일반 클래스 상속을 통해 타입을 정의하면, 하나의 고정된 구조로만 표현이 가능하지만

, 현실 세계의 개념은 여러 타입이 겹치거나 혼합된느 경우가 많으므로 이는 적합하지 않음<br><br>

하지만, 인터페이스는 계층 구조 없이도 타입을 유연하게 표현 가능하므로 이러한 설계를 할 때는 인터페이스를 이용하는 것이 좋음<br><br>

**인터페이스는 디폴트 메서드를 제공**

인터페이스의 디폴트 메서드는 개발자에게 편리함을 제공해주지만, 제약이 존재

많은 인터페이스가 equals와 hashCode 같은 Object 메서드를 정의하고 있지만, 이를 디폴트 메서드로 정의해서는 안되며, 인터페이스는 필드를 가질  수 없고, public이 아닌 정적 멤버도 가질 수 없음 ( private 정적 메서드는 예외 )

마지막으로, 내가 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없음<br><br>

**인터페이스 + 추상 골격 구현 클래스**

`인터페이스와 추상 클래스의 장점을 모두 취하는 방법`

인터페이스로는 타입을 정의하고, 필요한다면 디폴트 메서드도 제공하며 골격은 추상 클래스에 구현하면 하위 클래스는 필요한 핵심 메서드만 구현하면 됨

⇒ 이게 바로 템플릿 메서드 패턴

( 관례상 인터페이스 이름이 Abc라면, 그 골격 구현 클래스의 이름은 AbstractAbc로 지음 )<br><br>

> 추상 골격 구현 클래스 : 인터페이스를 구현하며, 자주 쓰이는 로직을 공통적으로 미리 구현
>

<br><br>

`핵심 로직은 abstract 메서드로 남겨두고, 나머지는 미리 작성, 하위 클래스는 필수 메서드만 구현하면 동작이 완성`

> 템플릿 메서드 패턴 : 알고리즘 전체 흐름은 추상 클래스에서 정의하고 그 중 일부는 하위 클래스에서 구현하도록 하는 패턴
>

<br><br>

```kotlin
public interface Queue {
    void enqueue(String item);
    void process();
}

---

public abstract class AbstractQueue implements Queue { // 추상 골격 클래스
    @Override
    public void process() { // 템플릿 메서드
        logStart();            // 고정된 흐름
        doProcess();           // 하위 클래스에서 구현해야 함
        logEnd();              // 고정된 흐름
    }

    protected abstract void doProcess();  // hook 메서드

    private void logStart() {
        System.out.println("처리 시작");
    }

    private void logEnd() {
        System.out.println("처리 종료");
    }
}
```
<br>

골격 구현을 작성할 때는 먼저, 인터페이스의 메서드 중 다른 메서드들의 구현에 기반이 되는 핵심 메서드를 선정

이 핵심 메서드는 골격 구현 클래스에서 추상 메서드로 정의하고, 이를 이용하여 구현 가능한 나머지 메서드들은 디폴트 메서드로 인터페이스에 제공

단, equals, hashCode와 같은 Object의 메서드는 디폴트 메서드로 제공해서는 안됨

만약 인터페이스의 모든 메서드가 기반 메서드 또는 디폴트 메서드로 정의 가능하다면 골격 구현 클래스를 따로 만들 필요는 없음

하지만, 디폴트 메서드로 구현할 수 없는 메서드가 존재한다면, 해당 인터페이스를 구현하는 골격 구현 클래스를 작성하고 그 안에서 남은 메서드를 완성해주면 됨

골격 구현 클래스에는 필요하다면 public이 아닌 필드와 메서드를 추가해도 됨<br><br>

Ex ) Map.Entry 인터페이스

getKey(), getValue()는 확실히 기반 메서드 ( 이들만 구현되면 나머지 메서드는 이들을 이용하여 구현 가능 ), setValue()도 포함할 수도 있음

이 인터페이스는 equals와 hashCode의 동작 방식도 정의해놓았으며, 이들은 모두 골격 구현 클래스에 구현하고 toString()도 기반 메서드를 사용하여 구현함

```kotlin
interface Map.Entry<K, V> {
    K getKey();
    V getValue();
    V setValue(V value);  // 선택적
    boolean equals(Object o);
    int hashCode();
}

---

public abstract class AbstractMapEntry<K, V> implements Map.Entry<K, V> {
	@Override public V setValue(V value) {
		...
	}
	
	@Override
	public boolean equals(Object o) {
	  if (!(o instanceof Map.Entry)) return false;
    Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
    
    return Objects.equals(getKey(), e.getKey()) &&
	    Objects.equals(getValue(), e.getValue());
	}
	
	@Override
	public int hashCode() {
	    return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
	}
	
	@Override
	public String toString() {
	    return getKey() + "=" + getValue();
	}
}
```
<br>

**결론**

일반적으로 다중 구현 용 타입으로는 인터페이스가 가장 적합하며, 복잡한 인터페이스라면 골격 구현을 함께 제공하는 방식을 고려해보자

골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋음<br><br>

### 인터페이스는 구현하는 쪽을 생각하여 설계하자

---

기존 인터페이스에 디폴트 메서드를 사용하여 메서드를 추가할 수 있지만, 기존의 모든 구현체들과 문제를 일으킬 수 있음

기존의 구현체가 이미 동일한 시그니처의 메서드를 가지고 있다던지, 다중 인터페이스 상속 충돌 등 ..<br><br>

이렇게 예기치 않은 문제를 발생시킬 수 있기에 꼭 필요한 경우가 아니라면 기존 인터페이스에 디폴트 메서드를 추가하는 일은 피해야한다.

또한, 디폴트 메서드는 기존 인터페이스를 구현한 클래스들과의 호환성을 유지하면서 새로운 기능을 추가하기 위한 수단이지, 기존 메서드를 제거하거나 시그니처를 변경하기 위한 용도가 아님

```kotlin
// 원래 인터페이스와 이를 사용하는 구현체
interface Printer {
    void print(String message);
}

class ConsolePrinter implements Printer {
    public void print(String message) {
        System.out.println(message);
    }
}

-- 아래와 같이 바꾼다면 ??

interface Printer {
    // 기존 시그니처 제거하고
    // void print(String message);

    // 새로 바꿈 ( 추가 기능 넣으려고 )
    default void print(String message, boolean upperCase) {
        if (upperCase) System.out.println(message.toUpperCase());
        else System.out.println(message);
    }
}

⇒ 컴파일 오류
```
<br>

**결론**

디폴트 메서드를 통해 기존 인터페이스의 설계를 변경할 때는 주의해야 한다.<br><br>

### 인터페이스는 타입을 정의하는 용도로만 사용하자

---

인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 함

어떤 클래스가 인터페이스를 구현한다는 건, `“내 인스턴스는 이 인터페이스에 정의된 기능들을 할 수 있다"`를 외부에 알리는 것

⇒ 오직 이 용도로만 사용해야 함<br><br>

**상수 인터페이스는 이러한 지침을 위반** 

⇒ 인터페이스는 행동을 정의해야 하는데, 상수만 넣는 것은 인터페이스의 목적을 위반한 것<br><br>

**클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당하기 때문**

⇒ 상수는 클래스 내부에서만 쓰는 세부사항인데, 인터페이스를 통해 외부로 노출시키는 건 부적절하다는 의미<br><br>

**상수를 공개할 목적이라면 특정 클래스나 인터페이스와 강하게 연관된 상수일 때 추가해야 함**

Integer, Double에 선언된 `MIN_VALUE`, `MAX_VALUE`와 같은 것

열거 타입으로 나타내기 적합하다면 열거 타입으로 공개하고, 이것도 아니라면 인스턴스화 할 수 없는 유틸리티 클래스에 담아 공개하도록 하자

```kotlin
public class AppConstants {
    public static final int TIMEOUT_SECONDS = 30;

    private AppConstants() {}  // 인스턴스 생성 방지
}
```
<br>

만약 유틸리티 클래스를 통해 상수를 정의한다면 이를 사용할 때 클래스의 이름까지 함께 명시해야 함

( 자주 사용한다면 정적 임포트를 통해 클래스 이름은 생략할 수 있음 )<br><br>

### 태그 달린 클래스보다는 클래스 계층 구조를 사용하자

---

> 태그 달린 클래스 : 클래스 안에 type 같은 필드를 넣어서 그 값에 따라 동작을 분기하는 방식의 클래스
> 

```kotlin
public class Shape {
    enum ShapeType { RECTANGLE, CIRCLE }

    ShapeType type;

    double length;
    double width;

    double radius;

    double area() {
        switch (type) {
            case RECTANGLE: return length * width;
            case CIRCLE: return Math.PI * radius * radius;
            default: throw new AssertionError(type);
        }
    }
}

우선 열거 타입 선언, 태그 필드 switch문 들 쓸데 없는 코드가 많음
불필요한 필드가 존재하게 되며, 새로운 타입을 추가하게 되면 switch문을 수정해야 함 → OCP 위배
```
<br>

**클래스 계층 구조로 바꾼다면**

```kotlin
public abstract class Shape {
    abstract double area();
}

public class Rectangle extends Shape {
    double length, width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double area() {
        return length * width;
    }
}

public class Circle extends Shape {
    double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}

각 클래스가 자신의 데이터만 가지게 됨
새로운 도형이 생겨도 다른 클래스는 건드리지 않아도 됨 → OCP 만족
```
<br>

**태그 달린 클래스를 클래스 계층 구조로 변경하는 방법**

1. 먼저 root가 될 추상 클래스를 정의하고, 태그 값에 따라 동작이 달라지는 메서드들을 추상 메서드로 정의
2. 태그에 상관 없이 동작이 일정한 메서드들은 root 클래스에 일반 메서드로 추가
3. 모든 하위 클래스의 공통 데이터 필드 역시 root 클래스에 선언
4. root 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의<br><br>

### 멤버 클래스는 되도록 static으로 만들자

---

중첩 클래스란 다른 클래스 안에 정의된 클래스를 의미하며, 자신을 감싼 클래스에서만 쓰여야 하고 그 외로 사용하려면 탑레벨 클래스로 만들어야 함<br><br>

중첩 클래스의 종류 : 정적 멤버 클래스, ( 비정적 ) 멤버 클래스, 익명 클래스, 지역 클래스

( 첫 번째를 제외한 나머지는 내부 클래스에 해당 )<br><br>

**각각의 중첩 클래스를 언제, 왜 사용할까**

1. 정적 멤버 클래스
    
    `static 키워드로 선언된 클래스 내부의 클래스( 중첩 클래스 )`
    
    다른 클래스 안에서 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점을 제외하고 일반 클래스와 동일함
    
    흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 사용<br><br>
    
    Ex ) 계산기가 지원하는 연산의 종류를 정의하는 열거 타입
    
    Operation 열거 타입은 Calculator 클래스의 public 정적 멤버 클래스가 되어야 함
    
    ⇒ `Calculator.Operation.plus`, `Calculator.Operation.minus`와 같은 형태로 사용 가능<br><br>
    
    **정적 멤버 클래스와 비정적 멤버 클래스의 차이는 단지 static이 있고 없고지만, 의미상 차이가 존재**
    
    비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결되기 때문에 비정적 멤버 클래스의 인스턴스에서 정규화 된 this를 통해 바깥 인스턴스의 메서드를 호출하거나 참조를 가져올 수 있음
    
    ```kotlin
    public class OuterClass {
        private String outerField = "외부 필드";
    
        void outerMethod() {
            System.out.println("외부 메서드");
        }
    
        // 비정적 멤버 클래스
        class InnerClass {
            void accessOuter() {
                // 외부 클래스의 멤버에 직접 접근 가능
                System.out.println(outerField);
                outerMethod();
    
                // 정규화된 this를 이용해 외부 클래스 인스턴스를 참조
                OuterClass outer = OuterClass.this;
                outer.outerMethod();
            }
        }
    
        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            OuterClass.InnerClass inner = outer.new InnerClass();
            inner.accessOuter();
        }
    }
    ```
    <br>
    
    중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 함
    
    ⇒ 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문
    
    > 정적 멤버 클래스 : `Outer.Inner a = new Outer.Inner` 가 가능
    > 
    
    > 비정적 멤버 클래스 : 위와 같이 할 수 없음
    >

    <br><br>

2. 비정적 멤버 클래스
