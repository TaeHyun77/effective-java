### 클래스의 멤버와 접근 권한을 최소화하자

---

잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐임

⇒ 내부 구현 세부사항은 숨기고 다른 컴포넌트는 오직 공개된 API만 보고 사용, 서로의 내부 동작은 간섭 X

⇒ 정보 은닉 또는 캡슐화라고 불림<br><br>

> API : 외부에 공개된 기능을 의미
> 

> 여기서 API의 의미 : 외부에서 접근이 가능하냐 가능하지 않느냐
>
<br><br>

**캡슐화의 장점**

- 시스템 개발 속도를 높인다.
    
    여러 컴포넌트를 병렬적으로 개발할 수 있기 때문
    
- 시스템 관련 비용을 낮춘다.
    
    각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문
    
- 캡슐화가 성능을 높혀주지는 않지만, 최적화에 도움을 줌
    
    만약 어느 컴포넌트를 최적화 하고 싶다면 해당 컴포넌트만 하면 되기 때문
    
- 큰 시스템을 제작하는 난이도를 낮춰줌
    
    시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문<br><br>
    

자바는 이러한 캡슐화를 위한 다양한 장치를 제공하는데, 예를 들어 `접근 제어 매커니즘`임

⇒ 접근 제한자를 제대로 활용하는 것이 캡슐화의 핵심<br><br>

기본적으로 모든 클래스와 멤버의 접근성을 가능한 좁혀야한다 !

탑 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public이며, public으로 선언하면 공개 API가 되고, package-private으로 하면 해당 패키지 안에서만 이용할 수 있음<br><br>

패키지 외부에서 쓸 이유가 없다면 package-private로 선언하자 

⇒ API가 아닌 내부 구현이 되어 언제든 수정 가능

즉, 클라이언트에 아무런 피해 없이 다음 버전에서 수정, 교체, 제거 가능

하지만, public으로 선언한다면 API가 되므로 하위 호환을 위해 관리해줘야만 함<br><br>

**멤버에 부여할 수 있는 접근 제어자**

private : 멤버를 선언한 클래스에서만 접근 가능

package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 ( default )

( 인터페이스 멤버는 기본적으로 public )

protected : package-private의 범위를 포함하며, 다른 패키지더라도 하위 클래스에서는 접근 가능

public : 모든 곳에서 접근 가능<br><br>

**멤버 접근성을 최대한 줄이는 것이 좋지만, 이를 못하게 하는 제약이 하나 존재**

상위 클래스의 메서드를 재정의할 때, 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없는 것 ( 멤버는 제외 )

⇒ 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙

( 만약 상위 클래스의 접근 제어가 하위보다 넓다면 안되기 때문 - 리스코프 치환 원칙 )<br><br>

예외적으로 인터페이스를 구현한 클래스는 메서드를 반드시 public으로 선언해야 함<br><br>

**public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함**

필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됨

⇒ 이 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다는 의미 ( 외부에서 무시할 수 있기 때문 )

> 불변식 : 클래스가 항상 지켜야 하는 상태 조건
>
<br><br>

또한, 필드가 수정될 때 ( 예를 들어 락 ) 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않음

( public 가변 필드는 외부에서 락( lock ) 없이도 동시에 변경이 가능하기 때문 )<br><br>

하지만, 예외가 한 가지 있음 : 상수 ( public static final ) - 반드시 불변 객체나 기본 타입 값을 참조해야 함<br><br>

클래스에서 public static final 배열 필드를 두거나, 이 필드를 반환하는 접근자 메서드를 제공해서는 안됨

⇒ 이 배열의 내용을 수정할 수 있기 때문<br><br>

**자바 9에서의 모듈 시스템**

패키지가 클래스들의 묶음이듯이, 모듈은 패키지들의 묶음

모듈은 자신에 속하는 패키지 중 공개 가능할 것들을 선언하는데, protected, public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없음 ( 물론 모듈 안에서는 영향을 받지 않음 )

모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공개할 수 있음<br><br>

모듈에서 숨겨진 패키지 안에 있는 public, protected 접근 제어자는 전체가 모듈 안에서만 각각 public, protected 수준의 접근 수준을 가짐 

⇒ 모듈 내부로 한정되는 것<br><br>

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하자

---

때떄로 인스턴스 필드들만 모아놓는 클래스를 작성할 때가 있는데, 이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못함

```kotlin
class Point {
	public double x;
	public double y;
}
```
<br>

API를 수정하지 않고는 내부 표현을 바꿀 수도 없고, 불변식을 보장할 수도 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없음

따라서, 필드를 private로 바꾸고 public 접근자를 추가 ( getter ) 

```kotlin
class Point {
	private double x;
	private double y;

	public Point(double x, double y) {
		this.x = x;
		this.y = y;
	}
	
	public double getX() { return this.x; }
	public double getY() { return this.t; }
	
	public void setX(double x) { this.x = x; }
	public void setY(double y) { this.y = y; }
}
```
<br>

하지만, package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 문제가 없음

⇒ 외부에서 이 클래스에 접근할 수 없기 때문

이 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 됨<br><br>

public 클래스의 필드가 불변이라면 직접 노출할 때의 단점이 조금은 줄어들지만, 결코 좋은 생각은 아님

API를 변경하지 않고는 표현의 방식을 변경할 수 없고, 필드를 읽을 때 부수작업을 수행할 수 없기 때문<br><br>

각 인스턴스가 유효한 시간을 표현함을 보장하는 코드

```kotlin
public final class Time {
	private static final int HOURS_PER_DAY = 24;
	private static final int MINUTES_PER_HOUR = 60;
	
	public final int hour;
	public final int minute;
	
	public Time(int hour, int minute) {
		if (hour < 0 || hour >= HOURS_PER_DAY) 
			throw new Ex..
		if (minute < 0 || minute >= MINUTES_PER_HOUR) 
			throw Ex ..
			
		this.hour = hour;
		this.minute = minute;
	}
}
```
<br>

결론적으로 public 클래스는 절대 가변 필드를 직접 노출해서는 안되고, 불변 필드라면 덜 위험할 것 같지만 웬만하면 사용하지 않는 것이 좋음

하지만, package-private 클래스 혹은 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있음

⇒ 무조건 캡슐화 하는 것보다 클래스가 외부에 노출되지 않는 경우에는 필드를 노출하는게 더 효율적일 수 있음 

⇒ 굳이 getter, setter 사용하지 않아도 되는 등등 ..<br><br>

### 변경 가능성을 최소화하자

---

> 불변 클래스 : 인스턴스의 내부 값을 수정할 수 없는 클래스
> 

ex ) String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal …<br><br>

**불변 클래스를 사용하는 이유**

가변 클래스보다 설계하고 구현하기 쉬으며, 오류가 발생도 적고 안전하기 때문<br><br>

**클래스를 불변으로 만드는 다섯가지 원칙**

1. 객체의 상태를 변경하는 메서드 ( setter )를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다 ( 클래스를 final로 선언 or 이후 한 가지 방법 더 나옴 )
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private로 선언한다.
    
    외부 코드가 직접 접근 / 수정하지 못하게 막음
    
    기본 타입 필드나 불변 객체를 참조하는 필드를 public final로 선언만 해도 불변 객체가 되지만, 나중에 내부 표현을 바꾸지 못하게 될 수 있으니 권하지는 않음<br><br>
    
    > 내부 표현 : 클래스 내부에서 데이터를 저장하는 방식, 구조, 타입을 의미
    > 
    
    ```kotlin
    public class Money {
        public final int amount;
    }
    
    ⇒ public 이므로 외부에서 접근할 수 있음
    
    만약 int를 다른 타입으로 바꾸고 싶다면 바꾸는 순간, 외부 코드들 전부 에러 → 리팩터링 해야함
    
    따라서, 필드를 private로 선언하고, getter를 통해 접근할 수 있도록 하는 것이 좋음
    ```
    <br>
    
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    
    클래스에서 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 함
    
    ⇒ 생성자, 접근자 모두에서 방어적 복사를 하자<br><br>
    

**원칙에 의한 예제**

```kotlin
public final class Complex {
	private final double re;
	private final double im;
	
	public Complex (double re, double im) {
		this.re = re;
		this.im = im;
	}
	
	public double getRe() { return re; }
	public double getIm() { return im; }
	
	public Complex plus(Complex c) {
		return new Complex(re + c.re, im + c.im);
	}
	
	public Complex minus(Complex c) {
		return new Complex(re - c.re, im - c.im);
	}
	
	public Complex times(Complex c) {
		return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
	}
	
	@Override 
	public boolean equals(Object o) {
	
		if ( this == o ) return true;
		if ( !(o instanceOf Complex) ) return false;
		
		return Double.compare(re, c.re) == 0 && Double.compare(im, c.im) == 0;
	}
	
	@Override
	public int hashCode() {
		return 31 * Double.hashCode(re) + Double.hashCode(im);
	}
	
	@Override public String toString() {
		return "(" + re " " + " + im + "i)";
	}	
```

사칙연산 메서드들은 인스턴스 자신을 수정하지 않고 새로운 인스턴스를 생성하여 반환함

⇒ 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 패턴 : 함수형 프로그래밍<br><br>

이와 달리, 절차적 혹은 명령형 프로그래밍에서는 메서드에서 피연산자인 자신이 수정되어 자신의 상태가 변하게됨

또한, 메서드 명을 add와 같은 동사가 아닌 plus와 같은 전치사를 사용한 이유도 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조한 의도임

이런 식으로 함수형 프로그래밍을 사용한다면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 얻을 수 있음<br><br>

불변 객체는 근본적으로 여러 스레드가 동시에 사용해도 절대 훼손되지 않으므로 스레드 안전함 !

따라서, 불변 객체는 안심하고 공유할 수 있으며, 만약 불변 클래스를 만들었다면 한 번 만든 인스턴스를 최대한 재활용하는 것이 좋음

ex ) 상수<br><br>

불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있음

ex ) 박싱된 기본 타입 클래스들과 BigInteger가 여기에 속함

⇒ -128 ~ 127 범위는 내부 캐시에서 재사용하며, BigInteger 내부에는 여러 정적 팩터리를 제공함

이러한 정적 팩터리를 사용하면 여러 클라이어트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 ↓<br><br>

**불변 객체는 자유롭게 공유할 수 있으며, 불변 객체끼리는 내부 데이터를 공유할 수 있음**

```kotlin
List<String> commonList = List.of("A", "B");

User u1 = new User("Alice", commonList);
User u2 = new User("Bob", commonList);

// 가변 객체였다면 한 쪽에서 수정했을 때 다른 쪽에도 영향이 가지만, 불변 객체이기 때문에 상관 없음
```
<br>

**객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음**<br><br>

**불변 객체는 그 자체로 실패 원자성을 제공**

> 실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태이어야 한다는 성질
>
<br><br>

**불변 클래스에도 단점은 존재**

값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이며, 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용을 치뤄야 한다는 점<br><br>

**클래스가 불변임을 보장하기 위해 final로 선언할 수도 있지만, 다른 방법도 존재**

모든 생성자를 private 혹은 package-private로 만들고, public 정적 팩터리를 제공하는 방법<br><br>

왜 생성자를 private로 바꿀까 : 하위 클래스에서는 super() 호출이 안 되므로 사실상 상속이 안됨<br><br>

```kotlin
public class Complex {
	private final double re;
	private final double im;
	
	private Complex(double rm, double im) {
		this.re = re;
		this.im = im;
	}
	
	public static Complex valueOf(double rm, double im) {
		return new Complex(rm, im);
	}
}
```
<br>

불변 클래스의 규칙에서 모든 필드는 final이어야 하고, 어떤 메서드도 그 객체를 수정할 수 없다고 하였는데, 성능을 위해 조금은 완화할 수 있음

⇒ 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다.<br><br>

어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시 해놓기도 하는데, 이는 불변 객체는 내부 상태가 절대 바뀌지 않기 때문에, 한 번 계산된 값( ex. hashCode )을 안전하게 캐시해도 논리적 불변성이 유지됨

⇒ 불변 객체이기 때문에 가능한 것

⭐️ 가변 객체는 중간에 값이 바뀔 수 있기 때문에, hashCode() 같은 결과를 캐싱하는 전략을 사용할 수 없음 ⭐️<br><br>

**정리해보자면**

- getter가 있다고 해서 항상 setter가 있을 필요는 없으며, 클래스는 꼭 필요한 경우가 아니라면 불변이어야 함
- 단순한 값 객체 클래스는 웬만하면 불변 클래스로 만들자
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
    
    ⇒ 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어듦
    
    ⇒ 합당한 이유가 없다면 모든 필드는 private final이어야 함<br><br>
    
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 함
    
    ⇒ 객체의 모든 필드가 완전하고 올바른 값으로 세팅되어 있어야 한다는 의미
    
    ⇒ 즉, 객체 생성 후에는 절대 불완전한 상태가 되어서는 안됨 ( 객체 만들고 setter로 나중에 완성해야지 ❌ )
    
    확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안됨
    
    ⇒ 객체를 생성한 후에, 값을 설정하는 메서드 ( setter  등등 )을 외부에서 쓸 수 있게 하지마라는 의미
