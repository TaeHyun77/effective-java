Object는 인스턴스를 만들 수 있는 클래스지만, 실제로는 모든 클래스의 부모로 동작하며 상속을 통해 기능을 확장해서 사용하는 구조로 설계되어 있습니다.

Object에서 final이 아닌 메서드 ( equals, hashCode, toString, clone … )는 모두 재정의를 염두에 두고 설계된 거이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있음

따라서, Object를 상속하는 클래스, 즉 모든 클래스들은 이러한 메서드들을 일반 규약에 맞게 재정의 해야 함

만약 이를 잘못 구현한다면 대상 클래스가 이 규약을 준수한다고 가정하는 클래스( HashMap, HasgSet .. )를 오동작하게 만들 수 있음<br><br>

### equals는 일반 규약을 지켜 재정의 하자

---

equals는 재정의 하기 쉬워 보이지만 잘못한다면 끔찍한 결과를 초래하기에, 아예 재정의 하지 않는 것도 방법이지만, 재정의 하지 않는다면 어느 클래스의 인스턴스는 오직 자기 자신과만 같기 때문에 재정의가 필요하다면 해야함
<br><br>
**equals는 언제 재정의 해야할까 ?** 

객체 식별성 ( 두 객체가 물리적으로 같은지 )가 아니라 논리적 동치성을 확인해야 하는데, 주로 값 클래스가 해당

값 클래스는 Integer, String과 같은 값을 표현하는 클래스를 의미하며, 두 값 객체를 equals로 비교하고 싶다면 두 객체가 같은지가 아니라 값이 같은지를 알고싶을 것임

따라서 equals를 논리적 동치성을 확인하도록 재정의 한다면, 인스턴스의 값을 비교할 수 있게 됨<br><br>

**equals를 재정의 할 때 따라야 하는 일반 규약**

- 반사성
    
    null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true<br><br>
    
- 대칭성
    
    null이 아닌 모든 참조값 x, y에 대해 x.equals(y)가 true면 y.equals(x)도 true
    
    > 같은 클래스끼리만 대칭성이 지켜지면 되는 것이 아니라 모든 타입의 객체와의 비교에서, 대칭성은 항상 지켜져야 함
    >
    <br><br>
    
    ```kotlin
    // 대소문자 무시 비교를 위한 사용자 정의 문자열 클래스
    // 잘못된 코드 ( 대칭성 깨짐 )
    // s1.equalsIgnoreCase(s2) : 대소문자 구별하지 않고 비교
    public final class CaseInsensitiveString {
    	private final String s;
    	
    	public CaseInsensitiveString(String s) {
    		this.s = Objects.requireNonNull(s);
    	}
    	
    	@Override 
    	public boolean equals(Object o) {
    		if (o instanceOf CaseInsensitiveString) 
    			return s.equalsIgnoreCase(
    				((CaseInsensitiveString) o).s);
    		
    		if (o instanceOf String) 
    			return s.equalsIgnoreCase((String) o);
    			
    		return false;
    	}
    }
    ```
    
    ```kotlin
    CaseInsensitiveString c = new CaseInsensitiveString("Hello");
    String s = "hello";
    
    c.equals(s); // true (대소문자 무시)
    s.equals(c); // false ( 기본 String의 equals 실행됨 )
    
    따라서, 대칭성이 위배됨
    ```
    <br>
    
    **그럼 이 문제를 해결하려면 어떻게 해야할까 ??**
    
    CaseInsensitiveString의 equals를 String과 연동 ? → 에바<br><br>
    
    아래 코드와 같이 변경
    
    ```kotlin
    @Override 
    public boolean equals(Object o) {
    	
    	return o instanceOf CaseInsensitiveString && 
    		((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
    }
    ```
    
    CaseInsensitiveString 타입이 아닌 것과 비교할 시 항상 false를 반환하도록 설정
    
    이는 String의 equals에도 적용되므로 String.equals(C)와 C.equals(String) 도 항상 false로 같음
    
    즉 모든 equals 구현에 자기 타입과 같은 타입을 비교하지 않으면 false를 반환하게끔 설정<br><br>
    
- 추이성
    
    null이 아닌 모든 참조값 x, y, z에 대해 x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true<br><br>
    
    > 상위 클래스 instanceof 하위 클래스 → false
    > 
    
    > 하위 클래스 instanceof 상위 클래스 → true
    >
    <br><br>
    
    만약 하위 클래스에 상위 클래스에는 없는 새로운 필드를 추가한다면 추이성을 위반하게 됨
    
    ⭐️ 상위 클래스에서 재정의한 equals()는 하위 클래스에 그대로 상속되어 동작
    
    ```kotlin
    public class Point {
    	private final int x;
    	private final int y;
    	
    	public Point(int x, int y) {
    		this.x = x;
    		this.y = y;
    	}
    	
    	@Override public boolean equals(Object o) {
    		if (!(o instanceOf Point)) return false;
    		Point p = (Point) o;
    		return p.x == x && p.y == y;
    	}
    	...
    }
    ```
    <br>
    
    ```kotlin
    public class ColorPoint extends Point {
    	private final Color color;
    	
    	public ColorPoint(int x, int y, Color c) {
    		this.x = x;
    		this.y = y;
    		this.color = c;
    	}
    	
    	...
    }
    ```
    
    ⇒ 이대로 된다면 Point의 equals 구현이 상속되어 색상 정보는 무시한 채 비교를 수행하게 됨<br><br>
    
    ```kotlin
    // 잘못된 코드 - 대칭성 위배됨
    @Override public boolean equals(Object o) {
    	if (!(o instanceOf ColorPoint)) return false;
    	return super.equals(o) && ((ColorPoint) o).color == color;
    }
    ```
    
    ⇒ Point와 ColorPoint를 비교할 때 대칭성이 위반될 수 있음<br><br>
    
    ```kotlin
    // Point의 equals를 다음과 같이 구현한다면 ?? 
    // 추이성 위배
    @Override public boolean equals(Object o) {
    	if (!(o instanceOf Point)) return false;
    	
    	// o가 Point이면 색상을 무시하고 비교
    	if (!(o instanceOf ColorPoint))
    		return o.equals(this);
    	
    	// o가 ColorPoint이면 색상까지 비교
    	return super.equals(o) && ((ColorPoint) o).color == color;
    }
    
    // ColorPoint p1 = new ColorPoint(1, 2, Color.Red);
    // Point p = new Point(1, 2);
    // ColorPoint p3 = new ColorPoint(1, 2, Color.Blue);
    
    ⇒ 다음과 같다면 추이성이 위배됨
    ```
    
    ⇒ 이런 식으로 한다면 추이성이 위배도 되지만 상속 관계가 깊을수록 구현이 어려워짐 .. ..<br><br>
    
    **그럼 어떻게 해야할까 ??**
    
    구체 클래스를 확장해가며 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 없음 <br><br>
    
    만약 instanceOf를 getClass 비교로 바꾼다면 ?
    
    ⇒ 상위 클래스의 하위 클래스는 정의상 여전히 상위 클래스로서 활용되야 하는데, 이 방식에는 안되므로 그렇지 못함<br><br>
    
    상속 대신 컴포지션을 사용해라 
    
    ⇒ Point를 상속하는 대신 Point를 ColorPoint의 private 필드로 두고, ColorPoint와 같은 위치의 일반 Point를 반환하는 뷰 메서드를 public으로 추가하는 식
    
    ```kotlin
    public class ColorPoint  {
    	private final Point point;
    	private final Color color;
    	
    	public ColorPoint(int x, int y, Color color) {
    		point = new Point(x, y);
    		this.color = Objects.requiredNonNull(color);
    	}
    	
    	public Point asPoint() {
    		return point;
    	}
    	
    	@Override public boolean equals(Object o) {
    		if (!(o instanceOf ColorPoint)) return false;
    		
    		ColorPoint cp = (ColorPoint) o;
    		return cp.point.equals(point) && cp.color.equals(color);
    	}
    	...
    }
    ```
    <br>
    
    자바 라이브러리에도 구체 클래스를 확장하여 값을 추가한 클래스가 종종 있음
    
    한 가지 예로 `java.sql.TimeStamp`는 `java.util.Date`를 확장한 후 nanoseconds 필드를 추가하였는데, 따라서 `TimeStamp`의 equals는 대칭성을 위배하여 `Date` 객체와 섞어 사용하면 잘못 동작할 수 있음<br><br>
    
- 일관성
    
    null이 아닌 모든 참조값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true거나 항상 false를 반환
    
    가변 객체는 비교 시점에 따라 서로 같을수도 다를수도 있는 반면, 불변 객체는 계속 같거나 계속 달라야 함
    
    불변 클래스로 만들기로 했다면 equals가 계속 같거나 계속 다르다고 답 해야 함
    
    또한 불변이든 가변이든 equals 판단에 신뢰할 수 없는 자원이 끼어들면 안됨
    
    ⇒ 항시 메모리에 존재하는 객체만을 사용하여 결정적 계산만 수행해야 함<br><br>
    
- null 아님
    
    null이 아닌 모든 참조값 x에 대해 x.equals(null)은 false<br><br>
    
    모든 객체는 null과 같지 않음 → equals 구현에서 null인지 확인하여 자신을 보호
    
    ```kotlin
    @Override public boolean equals(Object o) {
    	if (o == null) return false;
    }
    ```
    <br>
    
    하지만 위와 같이 null 검사를 따로 해주기 보다 아래와 같은 instanceOf 검사로 타입 검사만 해주면 됨 
    
    ```kotlin
    @Override public boolean equals(Object o) {
    	if (!(o instanceOf Point)) return false;
    	...
    }
    ```
    
    ⇒ instanceOf 확인 검사에서 null 검사도 검사를 명시적으로 하지 않아도 됨<br><br>
    

이러한 규약을 어기면 프로그램이 이상하게 동작하고 종료될 것이기 때문에 지켜야 함<br><br>

### equals 메서드 구현 방법 정리

---

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인
    
    자기 자신이면 true를 반환<br><br>
    
2. instanceOf 연산자로 입력이 올바른 타입인지 확인
    
    만약 그렇지 않다면 false를 반환
    
    이때의 올바른 타입은 equals가 정의된 클래스인 것이 보통이지만, 가끔은 그 클래스가 구현한 특정 인터페이스가 될 수도 있음
    
    어떤 인터페이스는 자신을 구현한 서로 다른 클래스끼리도 비교할 수 있도록 equals 규약을 수정하기도 함<br><br>
    
    이런 인터페이스를 구현한 클래스라면 equals에서 클래스가 아닌 해당 인터페이스를 사용해야 함
    
    ⇒ Set, List, Map 등등의 컬렉션 인터페이스들이 여기 해당<br><br>
    
3. 입력을 올바른 타입으로 형 변환
    
    앞서 instanceOf 검사를 했기 때문에 이 단계는 100프로 성공<br><br>
    
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사
    
    모든 필드가 일치하면 true, 하나라도 다르면 false를 반환하도록 함<br><br>
    
    2단계에서 인터페이스를 사용했다면 입력의 필드 값을 가져올 때도 그 인터페이스의 메서드를 사용해야 함
    
    타입이 클래스라면 해당 필드에 직접 접근할 수도 있음<br><br>
    
5. equals를 재정의 할 때는 hashCode도 반드시 재정의 하자 ⭐️⭐️⭐️
6. 입력 타입은 항상 Object여야 함<br><br>

float와 double을 제외한 기본 타입 필드는 == 연산자로 비교하고, 참조 타입 필드는 각각의 equals 메서드로

, float와 double 필드는 각각 정적 메서드인 Float.compare(float, float)와 Double.compare(double, double)으로 비교<br><br>

어떤 필드를 먼저 비교하느냐에 따라 equals의 성능이 달라지기도 함

최적의 성능을 바란다면 다를 가능성이 더 크거나, 비교하는 비용이 싼 필드를 먼저 비교<br><br>

**equals 구현을 마쳤다면 대칭적인가 ? 추이성이 있는가 ? 일관적인가 ? 이 세 가지를 체크해보고 단위 테스트를 작성하여 체크해보는 것이 좋음**<br><br>

```kotlin
// 지금까지의 equals 구현 방법에 따른 전형적인 equals 메서드의 예

public final class PhoneNumber {
	private final short areaCode, prefix, lineNum;
	
	public PhoneNumber(int areaCode, int, prefix, int lineNum) {
		this.areaCode = rangeCheck(areaCode, 999, "지역코드");
		this.prefix = rangeCheck(prefix, 999, "프리픽스");
		this.lineNum = rangeCheck(lineNum, 9999, "가입자 번호");
	}
	
	public static short rangeCheck(int val, int max, String arg) {
		if (val < 0 || val > max) 
			throw new IllegalArgumentException(arg + ": " + val);
		return (short) val;
	}
	
	@Override public boolean equals(Object o) {
		if (o == this) return true;
		if (!(o instanceOf PhoneNumber)) return false;
		
		PhoneNumber pn = (PhoneNumber)o;
		
		return pn.lineNume == lineNum && pn.prefix == prefix && pn.areaCode == areaCode;
	}
	...
}
```
